import{_ as t,c as a,e as o,o as n}from"./app-DXjYgPyf.js";const r={};function i(p,e){return n(),a("div",null,[...e[0]||(e[0]=[o('<h2 id="todo" tabindex="-1"><a class="header-anchor" href="#todo"><span>TODO</span></a></h2><p>前面待补齐</p><h2 id="_2-7-为什么-0-1-0-2-不等于-0-3" tabindex="-1"><a class="header-anchor" href="#_2-7-为什么-0-1-0-2-不等于-0-3"><span>2.7 为什么 0.1 + 0.2 不等于 0.3 ?</span></a></h2><h3 id="q-为什么负数要用补码表示" tabindex="-1"><a class="header-anchor" href="#q-为什么负数要用补码表示"><span>Q：为什么负数要用补码表示?</span></a></h3><p>如果负数不是使用补码的方式表示，则在做基本对加减法运算的时候，还需要多一步操作来判断是否为负数，如果为负数，还得把加法反转成减法，或者把减法反转成加法，这就非常不好了，毕竟加减法运算在计算机里是很常使用的，所以为了性能考虑，应该要尽量简化这个运算过程。</p><h3 id="q-十进制小数怎么转成二进制" tabindex="-1"><a class="header-anchor" href="#q-十进制小数怎么转成二进制"><span>Q：十进制小数怎么转成二进制?</span></a></h3><p>十进制整数转二进制使用的是「除2取余法」，十进制小数使用的是「乘2 取整法」。</p><h3 id="q-计算机是怎么存小数的" tabindex="-1"><a class="header-anchor" href="#q-计算机是怎么存小数的"><span>Q：计算机是怎么存小数的?</span></a></h3><p>计算机是以浮点数的形式存储小数的，大多数计算机都是 IEEE 754 标准定义的浮点数格式，包含三个部分:</p><ul><li>符号位:表示数字是正数还是负数，为0表示正数，为1表示负数;</li><li>指数位:指定了小数点在数据中的位置，指数可以是负数，也可以是正数，指数位的长度越长则数值的表达范围就越大;</li><li>尾数位:小数点右侧的数字，也就是小数部分，比如二进制1.0011x2^(-2)，尾数部分就是 0011，而且尾数的长度决定了这个数的精度，因此如果要表示精度更高的小数，则就要提高尾数位的长度; 用 32 位来表示的浮点数，则称为单精度浮点数，也就是我们编程语言中的 float 变量，而用 64 位来表示的浮点数，称为双精度浮点数，也就是 double 变量。</li></ul><h3 id="q-0-1-0-2-0-3-吗" tabindex="-1"><a class="header-anchor" href="#q-0-1-0-2-0-3-吗"><span>Q：0.1 + 0.2 == 0.3 吗?</span></a></h3><p>不是的，0.1和 0.2 这两个数字用二进制表达会是一个一直循环的二进制数，比如0.1 的二进制表示为 0.0 0011 0011 0011..(0011 无限循环)，对于计算机而言，0.1无法精确表达，这是浮点数计算造成精度损失的根源。</p><p>因此，IEEE 754 标准定义的浮点数只能根据精度舍入，然后用「近似值」来表示该二进制，那么意味着计算机存放的小数可能不是一个真实值。</p><p>0.1 + 0.2 并不等于完整的 0.3，这主要是因为这两个小数无法用「完整」的二进制来表示，只能根据精度舍入，所以计算机里只能采用近似数的方式来保存，那两个近似数相加，得到的必然也是一个近似数。</p>',14)])])}const s=t(r,[["render",i]]),c=JSON.parse('{"path":"/eight/m44kbedw/","title":"二、硬件结构","lang":"zh-CN","frontmatter":{"title":"二、硬件结构","createTime":"2025/11/03 17:18:08","permalink":"/eight/m44kbedw/","description":"TODO 前面待补齐 2.7 为什么 0.1 + 0.2 不等于 0.3 ? Q：为什么负数要用补码表示? 如果负数不是使用补码的方式表示，则在做基本对加减法运算的时候，还需要多一步操作来判断是否为负数，如果为负数，还得把加法反转成减法，或者把减法反转成加法，这就非常不好了，毕竟加减法运算在计算机里是很常使用的，所以为了性能考虑，应该要尽量简化这个运算...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"二、硬件结构\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-11-05T06:04:21.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://www.ajohn.top/eight/m44kbedw/"}],["meta",{"property":"og:site_name","content":"AJohn Blog"}],["meta",{"property":"og:title","content":"二、硬件结构"}],["meta",{"property":"og:description","content":"TODO 前面待补齐 2.7 为什么 0.1 + 0.2 不等于 0.3 ? Q：为什么负数要用补码表示? 如果负数不是使用补码的方式表示，则在做基本对加减法运算的时候，还需要多一步操作来判断是否为负数，如果为负数，还得把加法反转成减法，或者把减法反转成加法，这就非常不好了，毕竟加减法运算在计算机里是很常使用的，所以为了性能考虑，应该要尽量简化这个运算..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-11-05T06:04:21.000Z"}],["meta",{"property":"article:modified_time","content":"2025-11-05T06:04:21.000Z"}]]},"readingTime":{"minutes":2.26,"words":679},"git":{"createdTime":1762322661000,"updatedTime":1762322661000,"contributors":[{"name":"zzyAJohn","username":"zzyAJohn","email":"1833302139@qq.com","commits":1,"avatar":"https://avatars.githubusercontent.com/zzyAJohn?v=4","url":"https://github.com/zzyAJohn"}]},"autoDesc":true,"filePathRelative":"eight/os/2.hardware.md","headers":[]}');export{s as comp,c as data};
