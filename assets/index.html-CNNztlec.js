import{_ as s,c as a,a as o,b as p,e as l,d as n,r as i,o as r}from"./app-C1ZOz49-.js";const d={};function h(f,t){const e=i("PDFViewer");return r(),a("div",null,[t[0]||(t[0]=o("h2",{id:"_1-转换函数",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#_1-转换函数"},[o("span",null,"1. 转换函数")])],-1)),t[1]||(t[1]=o("h3",{id:"_1-1-conversion-function",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#_1-1-conversion-function"},[o("span",null,"1.1 conversion function")])],-1)),p(e,{src:"https://oss.ajohn.top/blog/pdf/oop2.pdf",page:14,zoom:50,width:"100%",height:"",ratio:"",title:"oop2.pdf"}),t[2]||(t[2]=o("p",null,[n("在类内设计一个 "),o("code",null,"operator double()"),n(" ，可以把当前类型转换为double类型，注意要使用const。")],-1)),t[3]||(t[3]=o("p",null,[n("分析："),o("code",null,"double d = 4 + f;"),n(" 这一行代码是一个整型加 Fraction ，并返回一个 double 类型，因此会尝试把 Fraction 转换为整型或者浮点型， Fraction 内部正好设计了 "),o("code",null,"operator double()"),n(" ，因此编译可以通过。")],-1)),t[4]||(t[4]=o("h3",{id:"_1-2-non-explicit-one-argument-ctor",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#_1-2-non-explicit-one-argument-ctor"},[o("span",null,"1.2 non-explicit-one-argument ctor")])],-1)),p(e,{src:"https://oss.ajohn.top/blog/pdf/oop2.pdf",page:15,zoom:50,width:"100%",height:"",ratio:"",title:"oop2.pdf"}),t[5]||(t[5]=o("p",null,[n("分析："),o("code",null,"Fraction d2 = f + 4;"),n(" 这一行代码是一个 Fraction 加整型，并返回一个 Fraction 类型，此时我们没有提供类型转换函数，注意到我们的成员函数实现了 "),o("code",null,"operator+"),n(" 的重载，但其要求右边是一个 Fraction 对象，而这里是 4 ，编译器尝试把 4 构造成一个Fraction，注意到我们的构造函数内部只有一个实参，发现 4 可以转化为4/1，因此编译也可以通过。")],-1)),t[6]||(t[6]=o("h3",{id:"_1-3-conversion-function-vs-non-explicit-one-argument-ctor",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#_1-3-conversion-function-vs-non-explicit-one-argument-ctor"},[o("span",null,"1.3 conversion function vs.non-explicit-one-argument ctor")])],-1)),p(e,{src:"https://oss.ajohn.top/blog/pdf/oop2.pdf",page:16,zoom:50,width:"100%",height:"",ratio:"",title:"oop2.pdf"}),t[7]||(t[7]=o("p",null,"如果同时存在转换函数和操作符重载呢？两者都是合法的，编译器不知道该怎么处理，因此报错 ambiguous ，引发歧义。",-1)),t[8]||(t[8]=o("h3",{id:"_1-4-explicit-one-argument-ctor",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#_1-4-explicit-one-argument-ctor"},[o("span",null,"1.4 explicit-one-argument ctor")])],-1)),p(e,{src:"https://oss.ajohn.top/blog/pdf/oop2.pdf",page:17,zoom:50,width:"100%",height:"",ratio:"",title:"oop2.pdf"}),t[9]||(t[9]=o("p",null,[n("如果加上关键字 "),o("code",null,"explict"),n(" ，告诉编译器不要自动改变我的变量类型，那么此处 4 无法构造成一个 Fraction ，只能走转换函数把 f 转成 double ，那么两个 double 相加最后的结果也是 double ，而接受类型要一个 Fraction ，因此这里报的是 double 转 Fraction 的错误：conversion from 'double' to 'Fraction' requested")],-1)),t[10]||(t[10]=o("div",{class:"hint-container tip"},[o("p",{class:"hint-container-title"},"提示"),o("p",null,[o("code",null,"explict"),n(" 通常使用在构造函数的前面，极小一部分用在模板里。")])],-1)),t[11]||(t[11]=o("h3",{id:"_1-5-代理",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#_1-5-代理"},[o("span",null,"1.5 代理")])],-1)),p(e,{src:"https://oss.ajohn.top/blog/pdf/oop2.pdf",page:18,zoom:50,width:"100%",height:"",ratio:"",title:"oop2.pdf"}),t[12]||(t[12]=o("p",null,"这里本应该传回一个bool值，但是却传回 reference 去代表，这种手法叫做 代理(proxy)。",-1)),t[13]||(t[13]=o("p",null,[n("可以看到 reference 也就是 "),o("code",null,"_bit_reference"),n(" ，而查阅源码发现其确实是返回一个 bool 类型。")],-1)),t[14]||(t[14]=o("h2",{id:"_2-pointer-like-classes",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#_2-pointer-like-classes"},[o("span",null,"2. pointer-like classes")])],-1)),t[15]||(t[15]=o("p",null,"设计一个 class ，让它的行为像一个指针。",-1)),t[16]||(t[16]=o("h3",{id:"_2-1-智能指针",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#_2-1-智能指针"},[o("span",null,"2.1 智能指针")])],-1)),p(e,{src:"https://oss.ajohn.top/blog/pdf/oop2.pdf",page:19,zoom:50,width:"100%",height:"",ratio:"",title:"oop2.pdf"}),t[17]||(t[17]=l('<p>智能指针接受一个普通指针来把它转化为智能指针，其内部有两个常用的运算符重载：<code>*</code> 和 <code>-&gt;</code> ，这里稍有不同的是， <code>*</code> 作用于指针就消耗掉了，但是 <code>-&gt;</code> 得到的东西要继续用 <code>-&gt;</code> 作用上去。</p><h3 id="_2-2-迭代器" tabindex="-1"><a class="header-anchor" href="#_2-2-迭代器"><span>2.2 迭代器</span></a></h3>',2)),p(e,{src:"https://oss.ajohn.top/blog/pdf/oop2.pdf",page:20,zoom:50,width:"100%",height:"",ratio:"",title:"oop2.pdf"}),t[18]||(t[18]=o("p",null,[n("迭代器相比智能指针，需要移动指针去遍历容器，因此需要 "),o("code",null,"++"),n(),o("code",null,"--"),n(" 的操作。")],-1)),t[19]||(t[19]=o("h2",{id:"_3-function-like-classes",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#_3-function-like-classes"},[o("span",null,"3. function-like classes")])],-1)),t[20]||(t[20]=o("h3",{id:"_3-1-仿函数",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#_3-1-仿函数"},[o("span",null,"3.1 仿函数")])],-1)),p(e,{src:"https://oss.ajohn.top/blog/pdf/oop2.pdf",page:22,zoom:50,width:"100%",height:"",ratio:"",title:"oop2.pdf"}),t[21]||(t[21]=o("p",null,[n("设计一个 class ，让它的行为像一个函数，也就是能接受一个小括号的东西（类内定义 "),o("code",null,"operator()"),n(" ），就叫仿函数。")],-1)),t[22]||(t[22]=o("h3",{id:"_3-2-标准库中的仿函数的奇特模样",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#_3-2-标准库中的仿函数的奇特模样"},[o("span",null,"3.2 标准库中的仿函数的奇特模样")])],-1)),p(e,{src:"https://oss.ajohn.top/blog/pdf/oop2.pdf",page:24,zoom:50,width:"100%",height:"",ratio:"",title:"oop2.pdf"}),t[23]||(t[23]=o("p",null,"plus看似只要相加返回即可，为什么要继承？这里卖了个关子，标准库课程里再做介绍。",-1)),p(e,{src:"https://oss.ajohn.top/blog/pdf/oop2.pdf",page:25,zoom:50,width:"100%",height:"",ratio:"",title:"oop2.pdf"}),t[24]||(t[24]=o("p",null,"这里有一堆typedef，占用应该是0，但sizeof可能是1。",-1)),t[25]||(t[25]=o("h2",{id:"_4-namespace-经验谈",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#_4-namespace-经验谈"},[o("span",null,"4. namespace 经验谈")])],-1)),p(e,{src:"https://oss.ajohn.top/blog/pdf/oop2.pdf",page:26,zoom:50,width:"100%",height:"",ratio:"",title:"oop2.pdf"}),t[26]||(t[26]=o("p",null,"不同部门的函数和名称可能冲突，因此我们使用 namespace 来分离。",-1)),t[27]||(t[27]=o("h2",{id:"_5-class-template-类模板",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#_5-class-template-类模板"},[o("span",null,"5. class template, 类模板")])],-1)),p(e,{src:"https://oss.ajohn.top/blog/pdf/oop2.pdf",page:27,zoom:50,width:"100%",height:"",ratio:"",title:"oop2.pdf"}),t[28]||(t[28]=o("p",null,"在使用类模板时需指定类型。",-1)),t[29]||(t[29]=o("h2",{id:"_6-function-template-函数模板",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#_6-function-template-函数模板"},[o("span",null,"6. function template, 函数模板")])],-1)),p(e,{src:"https://oss.ajohn.top/blog/pdf/oop2.pdf",page:28,zoom:50,width:"100%",height:"",ratio:"",title:"oop2.pdf"}),t[30]||(t[30]=o("p",null,"函数模板使用一定是调用，因此无需指定类型，如果是自定义类型，那么会继续去查找运算符重载。",-1)),t[31]||(t[31]=o("h2",{id:"_7-成员模板",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#_7-成员模板"},[o("span",null,"7. 成员模板")])],-1)),t[32]||(t[32]=o("h3",{id:"_7-1-pair",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#_7-1-pair"},[o("span",null,"7.1 pair")])],-1)),p(e,{src:"https://oss.ajohn.top/blog/pdf/oop2.pdf",page:30,zoom:50,width:"100%",height:"",ratio:"",title:"oop2.pdf"}),t[33]||(t[33]=o("p",null,"pair 接受任意类型的T1，T2，但是拷贝构造函数要求U1，U2类型的p可以转型成T1，T2，换成文字解释就是说，鲫鱼和麻雀可以转成鱼类和鸟类，因此是允许的，但反过来就不行。",-1)),t[34]||(t[34]=o("h3",{id:"_7-2-shared-ptr",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#_7-2-shared-ptr"},[o("span",null,"7.2 shared_ptr")])],-1)),p(e,{src:"https://oss.ajohn.top/blog/pdf/oop2.pdf",page:31,zoom:50,width:"100%",height:"",ratio:"",title:"oop2.pdf"}),t[35]||(t[35]=o("p",null,"base 的指针可以指向 derived ，同理智能指针也应该如此，因此在源码中，我有一个指针_TP指向鱼类，那么赋初值的时候我可以给它一个鲫鱼的初值",-1)),t[36]||(t[36]=o("p",null,"up-cast：基类往往画在上面，指针可以向上移动。",-1)),t[37]||(t[37]=o("h3",{id:"_7-3-specialization-模板特化",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#_7-3-specialization-模板特化"},[o("span",null,"7.3 specialization, 模板特化")])],-1)),p(e,{src:"https://oss.ajohn.top/blog/pdf/oop2.pdf",page:32,zoom:50,width:"100%",height:"",ratio:"",title:"oop2.pdf"}),t[38]||(t[38]=o("p",null,"特化可以有任意个版本，运行时会优先匹配特化的版本，没有符合的特化版本则改为使用泛化版本。",-1)),t[39]||(t[39]=o("h3",{id:"_7-4-partial-specialization-模板偏特化-局部特化",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#_7-4-partial-specialization-模板偏特化-局部特化"},[o("span",null,"7.4 partial specialization, 模板偏特化（局部特化）")])],-1)),p(e,{src:"https://oss.ajohn.top/blog/pdf/oop2.pdf",page:33,zoom:50,width:"100%",height:"",ratio:"",title:"oop2.pdf"}),t[40]||(t[40]=o("ol",null,[o("li",null,"个数的偏：只绑定一个或部分，其他参数仍然使用泛化模板的默认参数")],-1)),p(e,{src:"https://oss.ajohn.top/blog/pdf/oop2.pdf",page:34,zoom:50,width:"100%",height:"",ratio:"",title:"oop2.pdf"}),t[41]||(t[41]=o("ol",{start:"2"},[o("li",null,"范围的偏：如果是指针类型，我们使用指针专属模板，非指针类型使用泛化版本。因此 obj1 使用上面的，obj2 使用下面的。")],-1)),t[42]||(t[42]=o("h3",{id:"_7-5-template-template-parameter-模板模板参数",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#_7-5-template-template-parameter-模板模板参数"},[o("span",null,"7.5 template template parameter, 模板模板参数")])],-1)),p(e,{src:"https://oss.ajohn.top/blog/pdf/oop2.pdf",page:35,zoom:50,width:"100%",height:"",ratio:"",title:"oop2.pdf"}),t[43]||(t[43]=o("p",null,"即模板的参数也是一个模板",-1)),t[44]||(t[44]=o("h3",{id:"_7-6-template-template-parameter",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#_7-6-template-template-parameter"},[o("span",null,"7.6 template template parameter")])],-1)),p(e,{src:"https://oss.ajohn.top/blog/pdf/oop2.pdf",page:37,zoom:50,width:"100%",height:"",ratio:"",title:"oop2.pdf"}),t[45]||(t[45]=l('<p>这里的参数 <code>list&lt;int&gt;</code> 已经被确定了，已经绑定了，因此这种写法不能叫模板模板参數。</p><h2 id="_8-关于c-标准库" tabindex="-1"><a class="header-anchor" href="#_8-关于c-标准库"><span>8. 关于C++标准库</span></a></h2><p>侯捷老师建议每个算法和容器都使用过</p><h2 id="_9-c-11的三个主题" tabindex="-1"><a class="header-anchor" href="#_9-c-11的三个主题"><span>9. C++11的三个主题</span></a></h2><p>C++11的一部分内容</p><h3 id="_9-1-variadic-templates-since-c-11-数量不定的模板参数" tabindex="-1"><a class="header-anchor" href="#_9-1-variadic-templates-since-c-11-数量不定的模板参数"><span>9.1 variadic templates (since C++11)数量不定的模板参数</span></a></h3>',6)),p(e,{src:"https://oss.ajohn.top/blog/pdf/oop2.pdf",page:43,zoom:50,width:"100%",height:"",ratio:"",title:"oop2.pdf"}),t[46]||(t[46]=o("p",null,[o("code",null,"typename..."),n(" 表示支持任意数量的类型")],-1)),t[47]||(t[47]=o("p",null,[o("code",null,"print(args...)"),n(" 递归调用自己，每次都把第一个参数打印出来，然后把剩下的一包再次分成一个和一包，直到分成一个和0个，打印完最后一个参数，我们还提供了一个空参数的 "),o("code",null,"print()"),n(" 。")],-1)),t[48]||(t[48]=o("p",null,[o("code",null,"sizeof...(args)"),n(" 可以知道这一包到底有多少变量。")],-1)),t[49]||(t[49]=o("h3",{id:"_9-2-auto",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#_9-2-auto"},[o("span",null,"9.2 auto")])],-1)),p(e,{src:"https://oss.ajohn.top/blog/pdf/oop2.pdf",page:44,zoom:50,width:"100%",height:"",ratio:"",title:"oop2.pdf"}),t[50]||(t[50]=o("p",null,"一种自动类型，适用那些肉眼很难推测出类型的变量，让编译器来帮忙推测",-1)),t[51]||(t[51]=o("h3",{id:"_9-3-ranged-base-for",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#_9-3-ranged-base-for"},[o("span",null,"9.3 ranged-base for")])],-1)),p(e,{src:"https://oss.ajohn.top/blog/pdf/oop2.pdf",page:45,zoom:50,width:"100%",height:"",ratio:"",title:"oop2.pdf"}),t[52]||(t[52]=l(`<div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-c++"><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">for</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">decl</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">coll</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    statement</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>每一轮从 coll 中取出一个容器内的元素 decl ，类似 python 的 <code>for num in nums:</code>，也是 pass by value，就是修改 decl 不会影响容器内的元素，除非使用&amp;。</p><h2 id="_10-reference" tabindex="-1"><a class="header-anchor" href="#_10-reference"><span>10. reference</span></a></h2>`,3)),p(e,{src:"https://oss.ajohn.top/blog/pdf/oop2.pdf",page:46,zoom:50,width:"100%",height:"",ratio:"",title:"oop2.pdf"}),t[53]||(t[53]=o("p",null,"引用和 const 一但赋予就不能改变",-1)),t[54]||(t[54]=o("h3",{id:"_10-1-reference-的常见用途",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#_10-1-reference-的常见用途"},[o("span",null,"10.1 reference 的常见用途")])],-1)),p(e,{src:"https://oss.ajohn.top/blog/pdf/oop2.pdf",page:48,zoom:50,width:"100%",height:"",ratio:"",title:"oop2.pdf"}),t[55]||(t[55]=l('<p>可以看出与传指针相比，传引用和传值操作非常统一，而且传引用无需创建副本，并在原数据直接修改，因此传引用的效率更高。</p><h2 id="_11-复合、继承、复合-继承关系下的构造和析构" tabindex="-1"><a class="header-anchor" href="#_11-复合、继承、复合-继承关系下的构造和析构"><span>11. 复合、继承、复合 + 继承关系下的构造和析构</span></a></h2><p>之前讲过，同前</p><h2 id="_12-对象模型-object-model" tabindex="-1"><a class="header-anchor" href="#_12-对象模型-object-model"><span>12. 对象模型（Object Model）</span></a></h2><h3 id="_12-1-关于vptr和vtbl" tabindex="-1"><a class="header-anchor" href="#_12-1-关于vptr和vtbl"><span>12.1 关于vptr和vtbl</span></a></h3>',5)),p(e,{src:"https://oss.ajohn.top/blog/pdf/oop2.pdf",page:53,zoom:50,width:"100%",height:"",ratio:"",title:"oop2.pdf"}),t[56]||(t[56]=o("p",null,"先来看三个类：class A有两个虚函数v1，、v2，两个成员函数f1、f2；class B重写了v1，没有重写v2，因此这里v2实际是A的v2，同时这里还重写了A的f1（理想情况子类不应该重写父类的非虚函数，但这里为了举例子这样写了），因此B内的函数为 B::v1、A::v2、A::f1、B::f2；同理class C重写了v1，没有重写v2，因此C内的函数为 C::v1、A::v2、A::f1、C::f2。因此一共有8种不同的函数，其中四种虚函数，那么当一个对象创建时，其内部会生成一个虚指针，指向该类的虚函数表，虚函数表内的地址决定了调用哪个虚函数。",-1)),t[57]||(t[57]=o("p",null,[o("code",null,"(*(p->vptr)[n])(p)"),n("：一层层来看，p指向一个C类对象，"),o("code",null,"p->vptr"),n(" ，调用内部的虚指针，此时来到虚函数表，"),o("code",null,"vbtl[n]"),n(" 从中取出某一个虚函数地址，"),o("code",null,"*"),n(" 通过地址解引用出要执行的虚函数，最后传递参数 "),o("code",null,"(p)"),n(" 到虚函数。")],-1)),p(e,{src:"https://oss.ajohn.top/blog/pdf/oop2.pdf",page:54,zoom:50,width:"100%",height:"",ratio:"",title:"oop2.pdf"}),t[58]||(t[58]=o("p",null,[o("code",null,"list<A*> myLst;"),n("：这样的好处是可以用 base 指针把所有子类放进一个容器内存储，当需要实例化的时候，只需要依次遍历，取出每一个指针，调用各自的 "),o("code",null,"draw()"),n(" 即可。")],-1)),t[59]||(t[59]=o("p",null,"多态就是在函数运行时进行动态绑定，要看 p 在 vptbl 中实际指向的是谁",-1)),t[60]||(t[60]=o("h3",{id:"_12-2-关于this",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#_12-2-关于this"},[o("span",null,"12.2 关于this")])],-1)),t[61]||(t[61]=o("p",null,"之前也讲过，省流：只用 virtual 重写我需要重写的方法，其他的按照 base 类提前写好的执行。",-1)),t[62]||(t[62]=o("h2",{id:"_13-谈谈const",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#_13-谈谈const"},[o("span",null,"13. 谈谈const")])],-1)),p(e,{src:"https://oss.ajohn.top/blog/pdf/oop2.pdf",page:59,zoom:50,width:"100%",height:"",ratio:"",title:"oop2.pdf"}),t[63]||(t[63]=o("p",null,"在成员函数后面加 const ，表明成员函数不打算改变 class 的 data ，并请求编译器来检查。",-1)),p(e,{src:"https://oss.ajohn.top/blog/pdf/oop2.pdf",page:60,zoom:50,width:"100%",height:"",ratio:"",title:"oop2.pdf"}),t[64]||(t[64]=o("p",null,"出错的情况：如果客户想使用一个 const 对象，而我们没有提供const成员函数，那么这种情况会报错。但反过来客户不使用const对象，而我们设计成员函数使用 const ，这是允许的，因此经常要考虑给成员函数加 const 。",-1)),t[65]||(t[65]=o("h2",{id:"_14-关于-new-deldete",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#_14-关于-new-deldete"},[o("span",null,"14. 关于 new, deldete")])],-1)),p(e,{src:"https://oss.ajohn.top/blog/pdf/oop2.pdf",page:61,zoom:50,width:"100%",height:"",ratio:"",title:"oop2.pdf"}),t[66]||(t[66]=o("p",null,"同前",-1)),t[67]||(t[67]=o("h3",{id:"_14-1-重载-operator-new-operator-delete-operator-new-operator-deletel",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#_14-1-重载-operator-new-operator-delete-operator-new-operator-deletel"},[o("span",null,"14.1 重载::operator new, ::operator delete, ::operator new[], ::operator deletel[]")])],-1)),p(e,{src:"https://oss.ajohn.top/blog/pdf/oop2.pdf",page:62,zoom:50,width:"100%",height:"",ratio:"",title:"oop2.pdf"}),t[68]||(t[68]=o("p",null,"这里的重载是在全局作用域，会影响到全局函数。",-1)),t[69]||(t[69]=o("blockquote",null,[o("p",null,"详情见《Effective C++》条款50：了解 new 和 delete 的合理替换时机")],-1)),t[70]||(t[70]=o("h3",{id:"_14-2-重载-member-operator-new-delete",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#_14-2-重载-member-operator-new-delete"},[o("span",null,"14.2 重载 member operator new/delete")])],-1)),p(e,{src:"https://oss.ajohn.top/blog/pdf/oop2.pdf",page:63,zoom:50,width:"100%",height:"",ratio:"",title:"oop2.pdf"}),t[71]||(t[71]=o("p",null,"这里是在类内重载，创建该类的对象时会重载。",-1)),t[72]||(t[72]=o("h3",{id:"_14-3-示例-接口",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#_14-3-示例-接口"},[o("span",null,"14.3 示例，接口")])],-1)),p(e,{src:"https://oss.ajohn.top/blog/pdf/oop2.pdf",page:65,zoom:50,width:"100%",height:"",ratio:"",title:"oop2.pdf"}),t[73]||(t[73]=o("p",null,"和变量作用域的逻辑一样，如果有类内重载先使用类内重载，没有则使用全局重载。",-1)),t[74]||(t[74]=o("p",null,[o("code",null,"::new"),n(" 会绕过类内重载的new，转而强制使用 globals 。")],-1)),t[75]||(t[75]=o("h3",{id:"_14-4-创建-array-类的大小分析",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#_14-4-创建-array-类的大小分析"},[o("span",null,"14.4 创建 Array 类的大小分析")])],-1)),p(e,{src:"https://oss.ajohn.top/blog/pdf/oop2.pdf",page:66,zoom:50,width:"100%",height:"",ratio:"",title:"oop2.pdf"}),t[76]||(t[76]=o("p",null,[n("来分析Foo的大小，结合上页ppt，一个int占4个byte，long也是，string内部是一个指针也是4，因此一个Foo的大小是12byte，"),o("code",null,"Foo* pArray = new Foo[5]"),n(" 创建了一个包含五个Foo的数组，那么按理说大小应该是 5 * 12 = 60byte，但是代码显示占了64byte，为什么这里多了4个字节？因为多出来的是一个Counter（计数器），这里数值为5，表示有5个元素，这样编译器才能知道要调用5次构造（析构）。")],-1)),t[77]||(t[77]=o("p",null,"下面是一个包含虚函数的例子，有虚函数就有虚指针，虚指针也是4byte，带有虚函数的Foo占用大小是16 byte，16 * 5 + 4 = 84byte，很合理。",-1)),t[78]||(t[78]=o("h3",{id:"_14-5-重载new-delete",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#_14-5-重载new-delete"},[o("span",null,"14.5 重载new(), delete()")])],-1)),p(e,{src:"https://oss.ajohn.top/blog/pdf/oop2.pdf",page:68,zoom:50,width:"100%",height:"",ratio:"",title:"oop2.pdf"}),t[79]||(t[79]=o("p",null,"new和delete依靠参数列表来重载，并且第一个参数必须是size_t，其余参数就是所谓的placement argument。",-1)),t[80]||(t[80]=o("p",null,"当你写一个 placement operator new，请确定也写出了对应的 placement operator delete。如果没有这样做，你的程序可能会发生隐微而时断时续的内存泄漏。当你声明 placement new和 placement delete，请确定不要无意识(非故意)地遮掩了它们的正常版本。",-1)),t[81]||(t[81]=o("blockquote",null,[o("p",null,"详情见《Effective C++》条款52：写了placement new也要写placement delete")],-1)),t[82]||(t[82]=o("h3",{id:"_14-6-basic-string-使用-new-extra-扩充申请量",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#_14-6-basic-string-使用-new-extra-扩充申请量"},[o("span",null,"14.6 basic_string 使用 new(extra) 扩充申请量")])],-1)),p(e,{src:"https://oss.ajohn.top/blog/pdf/oop2.pdf",page:71,zoom:50,width:"100%",height:"",ratio:"",title:"oop2.pdf"}),t[83]||(t[83]=o("p",null,"一个小应用：用 new(extra) 多申请一些资源",-1))])}const g=s(d,[["render",h]]),m=JSON.parse('{"path":"/cpp/fe5e8w3q/","title":"C++面向对象高级开发（下）","lang":"zh-CN","frontmatter":{"title":"C++面向对象高级开发（下）","createTime":"2025/09/07 17:19:29","permalink":"/cpp/fe5e8w3q/","description":"1. 转换函数 1.1 conversion function","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"C++面向对象高级开发（下）\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-10-28T11:44:01.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://www.ajohn.top/cpp/fe5e8w3q/"}],["meta",{"property":"og:site_name","content":"AJohn Blog"}],["meta",{"property":"og:title","content":"C++面向对象高级开发（下）"}],["meta",{"property":"og:description","content":"1. 转换函数 1.1 conversion function"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-28T11:44:01.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-28T11:44:01.000Z"}]]},"readingTime":{"minutes":9.03,"words":2708},"git":{"createdTime":1757292878000,"updatedTime":1761651841000,"contributors":[{"name":"zzyAJohn","username":"zzyAJohn","email":"1833302139@qq.com","commits":4,"avatar":"https://avatars.githubusercontent.com/zzyAJohn?v=4","url":"https://github.com/zzyAJohn"}]},"autoDesc":true,"filePathRelative":"cpp/senior/oop2.md","headers":[]}');export{g as comp,m as data};
