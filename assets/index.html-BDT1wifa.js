import{_ as r,c as n,a as t,b as o,e as p,r as s,o as i}from"./app-DXjYgPyf.js";const d={};function c(l,e){const a=s("PDFViewer");return i(),n("div",null,[e[0]||(e[0]=t("h2",{id:"_1-stl体系结构基础介绍",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#_1-stl体系结构基础介绍"},[t("span",null,"1. STL体系结构基础介绍")])],-1)),e[1]||(e[1]=t("h3",{id:"_1-1-stl六大部件",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#_1-1-stl六大部件"},[t("span",null,"1.1 STL六大部件")])],-1)),o(a,{src:"https://oss.ajohn.top/blog/pdf/stl1.pdf",page:12,zoom:50,width:"100%",height:"",ratio:"",title:"stl1.pdf"}),e[2]||(e[2]=p('<p><mark>分配器</mark>是负责支持容器的，帮容器分配内存。</p><p>与oop不同，数据保存在<mark>容器</mark>里，对数据的操作在<mark>算法</mark>里，中间的桥梁是<mark>迭代器</mark>（类似指针），</p><p><mark>仿函数</mark>的作用类似一个函数，在仿函数中自定义你要进行的算法操作（相加，相乘，排序）。</p><p><mark>适配器</mark>就是类似变压器，能够把输入的东西转换成我们需要的规格。</p><h3 id="_1-2-stl六大部件关系" tabindex="-1"><a class="header-anchor" href="#_1-2-stl六大部件关系"><span>1.2 STL六大部件关系</span></a></h3>',5)),o(a,{src:"https://oss.ajohn.top/blog/pdf/stl1.pdf",page:13,zoom:50,width:"100%",height:"",ratio:"",title:"stl1.pdf"}),e[3]||(e[3]=p('<p><code>vector</code> 是一个<mark>容器</mark>， <code>allocator&lt;int&gt;</code> 是默认的<mark>分配器</mark>，这里显示写出来了，注意内部 <code>&lt;int&gt;</code> 要与 <code>vector&lt;int&gt;</code> 保持一致。</p><p><code>count_if()</code> 是一个<mark>算法</mark>，用于统计满足某种情况的元素数量。内部的 <code>vi.begin()</code> 和 <code>vi.end()</code> 是两个迭代器，用来表示选定作用的区间（前闭后开）。</p><p><code>less&lt;int&gt;()</code> 是一个<mark>仿函数</mark>，作用是比大小，a小于b则为真，但是这里的接口不对，我们需要a小于40，因此使用 <code>bind2nd()</code> ，它是一个<mark>仿函数适配器</mark>，用于绑定第二参数40，这里就变成a小于40。</p><p><code>not1()</code>是一个<mark>仿函数适配器</mark>，作用是取反，让这里小于40的条件变为大于等于40。</p><p>综上，<code>not1(bind2nd(less&lt;int&gt;()，40))</code> 组成了一个判别式，大于等于40就为真，将其作为 <code>count_if</code> 的第三个参数，就能帮我们找出符合要求的元素。</p><h3 id="_1-3-其它" tabindex="-1"><a class="header-anchor" href="#_1-3-其它"><span>1.3 其它</span></a></h3><ul><li><p>复杂度</p></li><li><p>前闭后开</p></li><li><p>range-based for statement(since C++11)</p></li><li><p>auto keyword</p></li></ul><h2 id="_2-容器——结构与分类" tabindex="-1"><a class="header-anchor" href="#_2-容器——结构与分类"><span>2. 容器——结构与分类</span></a></h2>',8)),o(a,{src:"https://oss.ajohn.top/blog/pdf/stl1.pdf",page:18,zoom:50,width:"100%",height:"",ratio:"",title:"stl1.pdf"}),e[4]||(e[4]=p('<h3 id="_2-1-sequence-containers-序列容器" tabindex="-1"><a class="header-anchor" href="#_2-1-sequence-containers-序列容器"><span>2.1 Sequence Containers（序列容器）</span></a></h3><p>Array是固定长度的数组，不能删除也不能扩充。</p><p>Vector起点固定，但是尾端是可以动态扩充的（一般是两倍增长）。</p><p>Deque双端队列，两头都可以扩充。</p><p>List双向链表，包含前向指针和后向指针，因此占用空间更大，在某些实现中是环形。</p><p>Forward-List单向链表，占用空间更少。</p><h3 id="_2-2-associative-containers-关联容器" tabindex="-1"><a class="header-anchor" href="#_2-2-associative-containers-关联容器"><span>2.2 Associative Containers（关联容器）</span></a></h3><p>关联容器默认按照key值排序，适合快速查找，底层使用红黑树实现，是一种平衡二叉树。</p><h3 id="_2-3-unordered-containers-不定序容器-也是一种关联容器" tabindex="-1"><a class="header-anchor" href="#_2-3-unordered-containers-不定序容器-也是一种关联容器"><span>2.3 Unordered Containers（不定序容器，也是一种关联容器）</span></a></h3><p>底层使用hash table实现，通过散列函数也可以做到O(1)的时间来查找值，但是如果冲突过多会退化到O(n)，因此现在常用的策略是哈希表上存放指针来指向对象，发生冲突在此对象基础上继续套娃，当然如果某一列过长则需要重新设计散列函数。</p><h3 id="_2-4-各种测试" tabindex="-1"><a class="header-anchor" href="#_2-4-各种测试"><span>2.4 各种测试</span></a></h3><ul><li><p>测试程序的时候，可以使用namespace来区分，这样测试程序的变量名不会影响到正式程序。</p></li><li><p>头文件也写在每一个namespace的上面，而不是把所有头文件一股脑写在最上面，由于头文件有保护机制，相同的头文件并不会重复导入。</p></li><li><p>push_front会把所有元素都往后移，包括构造、析构，时间消耗很大，因此最好使用尾插法push_back。</p></li><li><p>有时候快速排序+二分查找并不比直接sort快，但我个人认为直接sort快是因为运气好罢了。</p></li><li><p>Forward-List和slist是一样的。</p></li><li><p>stack和queue都是deque实现的，为了防止破坏各自的特性，这两种容器（严格来说是容器适配器）没有迭代器。</p></li></ul><h3 id="_2-5-分配器之测试" tabindex="-1"><a class="header-anchor" href="#_2-5-分配器之测试"><span>2.5 分配器之测试</span></a></h3><p>模板都有第二个参数：默认分配器：std::allocator</p><p>GP</p><p>我不关心怎么比大小，因为比大小会触发操作符重载，由你自己定义</p><p>template&lt;&gt;表示特化</p><p>两个模板参数，但是确定一个模板参数，就是偏特化</p><h3 id="分配器" tabindex="-1"><a class="header-anchor" href="#分配器"><span>分配器</span></a></h3><p><code>allocator&lt;int&gt;()</code>构建了一个临时对象，还的时候要告知借了多少，因此不太实用。</p><h3 id="list" tabindex="-1"><a class="header-anchor" href="#list"><span>list</span></a></h3><p>数据部分：node 两个指针</p><p>所有的容器的iterator都设计成一个类，才能足够“聪明”</p><p>i++ 和 ++i</p><p>i++有参数</p><p>int不允许两次后++，因此我们的后++重载传回来的不含reference。</p>',26))])}const m=r(d,[["render",c]]),u=JSON.parse('{"path":"/cpp/6kfqpous/","title":"STL标准库和泛型编程","lang":"zh-CN","frontmatter":{"title":"STL标准库和泛型编程","createTime":"2025/09/24 15:28:25","permalink":"/cpp/6kfqpous/","description":"1. STL体系结构基础介绍 1.1 STL六大部件","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"STL标准库和泛型编程\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-10-28T11:44:01.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://www.ajohn.top/cpp/6kfqpous/"}],["meta",{"property":"og:site_name","content":"AJohn Blog"}],["meta",{"property":"og:title","content":"STL标准库和泛型编程"}],["meta",{"property":"og:description","content":"1. STL体系结构基础介绍 1.1 STL六大部件"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-28T11:44:01.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-28T11:44:01.000Z"}]]},"readingTime":{"minutes":3.58,"words":1074},"git":{"createdTime":1758883382000,"updatedTime":1761651841000,"contributors":[{"name":"zzyAJohn","username":"zzyAJohn","email":"1833302139@qq.com","commits":2,"avatar":"https://avatars.githubusercontent.com/zzyAJohn?v=4","url":"https://github.com/zzyAJohn"}]},"autoDesc":true,"filePathRelative":"cpp/STL/stl.md","headers":[]}');export{m as comp,u as data};
