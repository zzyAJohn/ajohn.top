---
title: 《C++ Primer》——在读
createTime: 2025/06/06 19:22:51
permalink: /read/x77skino/
---

这本久负盛名的 C++经典教程，时隔八年之久，终迎来史无前例的重大升级。除令全球无数程序员从中受益，甚至为之迷醉的——C++ 大师 Stanley B. Lippman 的丰富实践经验，C++标准委员会原负责人 Josée Lajoie 对C++标准的深入理解，以及C++ 先驱 Barbara E. Moo 在 C++教学方面的真知灼见外，更是基于全新的 C++11标准进行了全面而彻底的内容更新。非常难能可贵的是，《C++ Primer 中文版(第5版)》所有示例均全部采用 C++11 标准改写，这在经典升级版中极其罕见——充分体现了 C++ 语言的重大进展及其全面实践。书中丰富的教学辅助内容、醒目的知识点提示，以及精心组织的编程示范，让这本书在 C++ 领域的权威地位更加不可动摇。无论是初学者入门，或是中、高级程序员提升，本书均为不容置疑的首选。

<LinkCard title="《C++ Primer 中文版（第 5 版）》" href="https://zh.z-lib.gd/book/5424113/ce0a28/c-primer-%E4%B8%AD%E6%96%87%E7%89%88%E7%AC%AC-5-%E7%89%88.html"/>

## 序

> 本书在讲解的时候，常常会提到“编译器会如何如何”，学习语言的一个境界是把自己想象成编译器，这种要求对于一般的程序设计语言可能太高了，但是对于学习C和C++语言是最理想的方法。

> C++最大的力量不在于其抽象，恰恰在于其不抽象。

> 这么多的风格共存于一种语言，就是其强大抽象机制的证明。但是，在C++11以前，C++的抽象可以说存在若干缺陷，其中最严重的是缺少自动内存管理和对象级别的消息发送机制。今天看来，C++98只能说是特定历史条件造成的半成品，无论是从语言机制，还是标准库完备程度来说，可以说都存在明显的、不容忽略的缺陷。其直接后果，就是优雅性的缺失和效率的降低。

> 差不多十年前，我提出一个观点,每一个具体的技术领域，只需要读四五本书就够了。以前的C++是个例外，因为语言设计有缺陷，所以要读很多书才知道如何绕过缺陷。现在的C++11完全可以了,大家读四五本书就可以达到合格的水平,这恰恰是语言进步的体现。

> 本书是这四五本中的一本，而且是“教程+参考书”，扛梁之作，初学者的不二法门。另一本是《C++标准程序库》，对于C++熟手来说更为快捷。Scott Meyers的 Efeclive C++永远是学习C++者必读的,只不过这本书的第4版不知道什么时候出来。Anthony Williams的C++Concurrencyin Action是学习用标准C++开发并发程序的最佳选择。国内的作品，我则高度推荐陈硕的《Linux 多线程服务端编程》。这本书的名字赶跑了不少潜在的读者，所以我要特别说明一下。这本书是C++开发的高水平作品，与其说是教你怎么用C++写服务端开发，不如说是教你如何以服务端开发为例子提升C++开发水平。前面几本书都是谈标准C++自己的事情，碰到像iostream 这样失败的标准组件也不得不硬着头皮介绍。而这本书是接地气的实践结晶，告诉你面对具体问题时应怎样权衡，C++里什么好用，什么不好用，为什么，等等。


## 第 1 章 开始


::: note 包含来自标准库的头文件时，也应该用尖括号(<>)包围头文件名。对于不属于标准库的头文件，则用双引号("")包围。
:::

## 第 I 部分 C++ 基础

## 第 2 章 变量和基本类型

::: tip 建议:如何选择类型
和C语言一样，C++的设计准则之一也是尽可能地接近硬件。C++的算术类型必须满足各种硬件特质，所以它们常常显得繁杂而令人不知所措。事实上，大多数程序员能够(也应该)对数据类型的使用做出限定从而简化选择的过程。以下是选择类型的一些经验准则:
当明确知晓数值不可能为负时，选用无符导类型。使用int执行整数运算。在实际应用中，short常常显得太小而1ong一般和int有一样的尺寸。如果你的数值超过了int的表示范围，选用1onglong。在算术表达式中不要使用char或boo1，只有在存放字符或布尔值时才使用它们。因为类型char在一些机器上是有符号的，而在另一些机器上又是无符号的所以如果使用char进行运算特别容易出问题。如果你需要使用一个不大的整数那么明确指定它的类型是signed char或者unsigned char。
执行浮点数运算选用double，这是因为f1oat通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。事实上，对于某些机器来说，双精度运算甚至比单精度还快。1ongdouble提供的精度在一般情况下是没有必要的，况且它带来的运行时消耗也不容忽视。
:::

::: tip 建议:避免无法预知和依赖于实现环境的行为
无法预知的行为源于编译器无须(有时是不能)检测的错误。即使代码编译通过了如果程序执行了一条未定义的表达式，仍有可能产生错误。
不幸的是,在某些情况和/或某些编译器下,含有无法预知行为的程序也能正确执行但是我们却无法保证同样一个程序在别的编译器下能正常工作，甚至已经编译通过的代码再次执行也可能会出错。此外，也不能认为这样的程序对一组输入有效，对另一组输入就一定有效。
程序也应该尽量避免依赖于实现环境的行为。如果我们把int的尺寸看成是一个确定不变的已知值，那么这样的程序就称作不可移植的(nonportable)。当程序移植到别的机器上后，依赖于实现环境的程序就可能发生错误。要从过去的代码中定位这类错误可不是一件轻松愉快的工作。
:::

::: tip 提示:切勿混用带符号类型和无符号类型
如果表达式里既有带符号类型又有无符号类型，当带符号类型取值为负时会出现异常结果，这是因为带符号数会自动地转换成无符号数。例如，在一个形如a*b的式子中，如果a--1，b=1，而且a和b都是int，则表达式的值显然为-1。然而，如果a是int，而b是unsigned，则结果须视在当前机器上int所占位数而定。在我们的环境里，结果是4294967295。
:::


::: note 字符和字符串字面值
由单引号括起来的一个字符称为char型字面值，双引号括起来的零个或多个字符则构成字符串型字面值。
```C++
'a'//字符字面值
"Hello World!”//字符串宇面值
```
字符串字面值的类型实际上是由常量字符构成的**数组(aray)**。编译器在每个字符串的结尾处添加一个空字符("\0”)，因此，字符串字面值的实际长度要比它的内容多1。例如，字面值"'表示的就是单独的字符A，而字符串"A"则代表了一个字符的数组，该数组包含两个字符:一个是字母A、另一个是空字符。如果两个字符串字面值位置紧邻且仅由空格、缩进和换行符分隔，则它们实际上是一个整体。当书写的字符串字面值比较长，写在一行里不太合适时，就可以采取分开书写的方式:
```C++
//分多行书写的字符串字面值
std::cout<<"a really,really long string literal "
           "that spans two lines"<< std::endl;
```
:::

::: tip 术语:何为对象?
C++程序员们在很多场合都会使用对象(object)这个名词。通常情况下，对象是指一块能存储数据并具有某种类型的内存空间。
一些人仅在与类有关的场景下才使用“对象”这个词。另一些人则已把命名的对象和未命名的对象区分开来，他们把命名了的对象叫做变量。还有一些人把对象和值区分开来，其中对象指能被程序修改的数据，而值(value)指只读的数据。
本书遵循大多数人的习惯用法，即认为对象是具有某种数据类型的内存空间。我们在使用对象这个词时,并不严格区分是类还是内置类型,也不区分是否命名或是否只读。
:::

::: warning
初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。
:::

::: note
定义于函数体内的内置类型的对象如果没有初始化，则其值未定义。类的对象如果没有显式地初始化，则其值由类确定。
:::

::: tip 提示:未初始化变量引发运行时故障
未初始化的变量含有一个不确定的值，使用未初始化变量的值是一种错误的编程行为并且很难调试。尽管大多数编译器都能对一部分使用未初始化变量的行为提出警告，但严格来说，编译器并未被要求检查此类错误。
使用未初始化的变量将带来无法预计的后果。有时我们足够幸运，一访问此类对象程序就崩溃并报错，此时只要找到崩溃的位置就很容易发现变量没被初始化的问题。另外一些时候，程序会一直执行完并产生错误的结果。更糟糕的情况是，程序结果时对时错、无法把握。而且，往无关的位置添加代码还会导致我们误以为程序对了，其实结果仍旧有错。
建议初始化每一个内置类型的变量。虽然并非必须这么做，但如果我们不能确保初始化后程序安全，那么这么做不失为一种简单可靠的方法。
:::

::: note 变量能且只能被定义一次，但是可以被多次声明。
:::

::: note 声明和定义的区别看起来也许微不足道，但实际上却非常重要。如果要在多个文件中使用同一个变量，就必须将声明和定义分离。此时，变量的定义必须出现在且只能出现在个文件中，而其他用到该变量的文件必须对其进行声明，却绝对不能重复定义。
:::

::: note 关键概念:静态类型
C++是一种静态类型(staticallytyped)语言，其含义是在编译阶段检查类型。其中检查类型的过程称为类型检查(typechecking)
我们已经知道，对象的类型决定了对象所能参与的运算。在C+语言中，编译器负贵检查数据类型是否支持要执行的运算，如果试图执行类型不支持的运算，编译器将报错并且不会生成可执行文件。
程序越复杂，静态类型检查越有助于发现问题。然而，前提是编译器必须知道每一个实体对象的类型，这就要求我们在使用某个变量之前必须声明其类型。
:::

::: tip 建议:当你第一次使用变量时再定义它
一般来说，在对象第一次被使用的地方附近定义它是一种好的选择，因为这样做有助于更容易地找到变量的定义。更重要的是，当变量的定义与它第一次被使用的地方很近时，我们也会赋给它一个比较合理的初始值。
:::

::: warning
如果函数有可能用到某全局变量，则不宜再定义一个同名的局部变量
:::

::: note C++11中新增了一种引用:所谓的“右值引用(rvalue reference)”，这种引用主要用于内置类。严格来说当我们使用术语“引用(reference)”时，指的其实是“左值引用(lvalue reference )"
:::

::: note 一般在初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值绑定(bind)在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。
:::

::: note 引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。
:::

::: warning
指针通常难以理解，即使是有经验的程序员也常常因为调试指针引发的错误而被备受折磨。
:::

::: note 解引用操作仅适用于那些确实指向了某个对象的有效指针
:::

::: note 关键概念:某些符号有多重含义
像&和*这样的符号，既能用作表达式里的运算符，也能作为声明的一部分出现，符号的上下文决定了符号的意义:
```C++
int i = 42;
int &r = i; //&紧随类型名出现，因此是声明的一部分，上是一个引用
int *p; //*紧随类型名出现，因此是声明的一部分，P是一个指针
p = &i; //&出现在表达式中，是一个取地址符
*p = i; //*出现在表达式中，是一个解引用符
int &r2 = *p; //&是声明的一部分，*是一个解引用符
```
在声明语句中，&和*用于组成复合类型:在表达式中，它们的角色又转变成运算符。在不同场景下出现的虽然是同一个符号，但是由于含义截然不同，所以我们完全可以把它当作不同的符号来看待。
:::

::: tip 建议:初始化所有指针
使用未经初始化的指针是引发运行时错误的一大原因。
和其他变量一样，访问未经初始化的指针所引发的后果也是无法预计的。通常这一行为将造成程序崩溃，而且一旦崩溃，要想定位到出错位置将是特别棘手的问题。
在大多数编译器环境下，如果使用了未经初始化的指针，则该指针所占内存空问的当前内容将被看作一个地址值。访问该指针，相当于去访问一个本不存在的位置上的本不存在的对象。糟糕的是，如果指针所占内存空间中恰好有内容，而这些内容又被当作了某个地址，我们就很难分清它到底是合法的还是非法的了。
因此建议初始化所有的指针，并且在可能的情况下，尽量等定义了对象之后再定义指向它的指针。如果实在不清楚指针应该指向何处，就把它初始化为nullptr或者0，这样程序就能检测并知道它没有指向任何具体的对象了。
:::

::: warning
很多程序员容易迷惑于基本数据类型和类型修饰符的关系，其实后者不过是声明符的一部分罢了。
:::

::: note
经常有一种观点会误以为，在定义语句中，类型修饰符(*或&)作用于本次定义的全部变量。造成这种错误看法的原因有很多，其中之一是我们可以把空格写在类型修饰符和变量名中间:
```C++
int* p; //合法但是容易产生误导
```
我们说这种写法可能产生误导是因为int*放在一起好像是这条语句中所有变量共同的类型一样。其实恰恰相反，基本数据类型是int而非int*。*仅仅是修饰了p而己，对该声明语句中的其他变量，它并不产生任何作用:
```C++
int* p1，p2; //p1是指向int的指针，P2是int
```
涉及指针或引用的声明，一般有两种写法。第一种把修饰符和变量标识符写在一起:
```C++
int *p1，*p2; //p1和p2 都是指向 int 的指针这种形式着重强调变量具有的复合类型。第二种把修饰符和类型名写在一起，并且每条语句只定义一个变量:
```
这种形式着重强调本次声明定义了一种复合类型。
```C++
int* p1; // p1是指向 int 的指针
int* p2; // p2是指向int的指针
```
上述两种定义指针或引用的不同方法没有孰对孰错之分，关键是选择并坚持其中的一种写法，不要总是变来变去。
:::

::: tip
面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清楚它的真实含义。
:::

::: important
因为const对象一旦创建后其值就不能再改变,所以const对象必须初始化（和引用类似）。
:::

::: note
为了支持这一用法，同时避免对同一变量的重复定义，默认情况下，const对象被设定为仅在文件内有效。当多个文件中出现了同名的 const 变量时，其实等同于在不同文件中分别定义了独立的变量。

::: note
如果想在多个文件之间共享const对象,必须在变量的定义之前添加extern关键字。
:::

::: note 术语:常量引用是对const的引用
C++程序员们经常把词组“对const的引用”简称为“常量引用”，这一简称还是挺靠谱的，不过前提是你得时刻记得这就是个简称而已。
严格来说，并不存在常量引用。因为引用不是一个对象，所以我们没法让引用本身恒定不变。事实上，由于C++语言并不允许随意改变引用所绑定的对象，所以从这层意义上理解所有的引用又都算是常量。引用的对象是常量还是非常量可以决定其所能参与的操作，却无论如何都不会影响到引用和对象的绑定关系本身。
:::

::: tip
试试这样想吧:所谓指向常量的指针或引用，不过是指针或引用“自以为是罢了，它们觉得自己指向了常量，所以自觉地不去改变所指对象的值。
:::


常量指针将一直指向对象，不可改变指向，可以访问对象，可以修改对象的值。
int i = 0;
int *const p = &i;

指针常量



如果你需要判断，可以从右往左读，比如：

int * const p：p 是常量 → 指针常量。指针指向固定，可以改数据。

const int * p：p 指向常量 → 常量指针。数据固定，可以改指向。


int * const p 顶层const
const int * p 底层const

在拷贝时，顶层const一般无所谓，但是如果要操作一个底层const，则一般也需要定义一个const

常量表达式：有const并且具体值已知

::: tip
一般来说，如果你认定变量是一个常量表达式，那就把它声明成constexpr类型
:::

别名声明：
```C++
typedef double db;
db num = 3.14
```
新标准：
```C++
using db = double
db num = 3.14
```