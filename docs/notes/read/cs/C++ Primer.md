---
title: 《C++ Primer》——在读
createTime: 2025/06/06 19:22:51
permalink: /read/x77skino/
---

这本久负盛名的 C++经典教程，时隔八年之久，终迎来史无前例的重大升级。除令全球无数程序员从中受益，甚至为之迷醉的——C++ 大师 Stanley B. Lippman 的丰富实践经验，C++标准委员会原负责人 Josée Lajoie 对C++标准的深入理解，以及C++ 先驱 Barbara E. Moo 在 C++教学方面的真知灼见外，更是基于全新的 C++11标准进行了全面而彻底的内容更新。非常难能可贵的是，《C++ Primer 中文版(第5版)》所有示例均全部采用 C++11 标准改写，这在经典升级版中极其罕见——充分体现了 C++ 语言的重大进展及其全面实践。书中丰富的教学辅助内容、醒目的知识点提示，以及精心组织的编程示范，让这本书在 C++ 领域的权威地位更加不可动摇。无论是初学者入门，或是中、高级程序员提升，本书均为不容置疑的首选。

<LinkCard title="《C++ Primer 中文版（第 5 版）》" href="https://zh.z-lib.gd/book/5424113/ce0a28/c-primer-%E4%B8%AD%E6%96%87%E7%89%88%E7%AC%AC-5-%E7%89%88.html"/>

## 序

> 本书在讲解的时候，常常会提到“编译器会如何如何”，学习语言的一个境界是把自己想象成编译器，这种要求对于一般的程序设计语言可能太高了，但是对于学习C和C++语言是最理想的方法。

> C++最大的力量不在于其抽象，恰恰在于其不抽象。

> 这么多的风格共存于一种语言，就是其强大抽象机制的证明。但是，在C++11以前，C++的抽象可以说存在若干缺陷，其中最严重的是缺少自动内存管理和对象级别的消息发送机制。今天看来，C++98只能说是特定历史条件造成的半成品，无论是从语言机制，还是标准库完备程度来说，可以说都存在明显的、不容忽略的缺陷。其直接后果，就是优雅性的缺失和效率的降低。

> 差不多十年前，我提出一个观点,每一个具体的技术领域，只需要读四五本书就够了。以前的C++是个例外，因为语言设计有缺陷，所以要读很多书才知道如何绕过缺陷。现在的C++11完全可以了,大家读四五本书就可以达到合格的水平,这恰恰是语言进步的体现。

> 本书是这四五本中的一本，而且是“教程+参考书”，扛梁之作，初学者的不二法门。另一本是《C++标准程序库》，对于C++熟手来说更为快捷。Scott Meyers的 Efeclive C++永远是学习C++者必读的,只不过这本书的第4版不知道什么时候出来。Anthony Williams的C++Concurrencyin Action是学习用标准C++开发并发程序的最佳选择。国内的作品，我则高度推荐陈硕的《Linux 多线程服务端编程》。这本书的名字赶跑了不少潜在的读者，所以我要特别说明一下。这本书是C++开发的高水平作品，与其说是教你怎么用C++写服务端开发，不如说是教你如何以服务端开发为例子提升C++开发水平。前面几本书都是谈标准C++自己的事情，碰到像iostream 这样失败的标准组件也不得不硬着头皮介绍。而这本书是接地气的实践结晶，告诉你面对具体问题时应怎样权衡，C++里什么好用，什么不好用，为什么，等等。


## 第 1 章 开始


::: note 包含来自标准库的头文件时，也应该用尖括号(<>)包围头文件名。对于不属于标准库的头文件，则用双引号("")包围。
:::

## 第 I 部分 C++ 基础

## 第 2 章 变量和基本类型

### 2.1 基本内置类型

::: tip 建议:如何选择类型
和C语言一样，C++的设计准则之一也是尽可能地接近硬件。C++的算术类型必须满足各种硬件特质，所以它们常常显得繁杂而令人不知所措。事实上，大多数程序员能够(也应该)对数据类型的使用做出限定从而简化选择的过程。以下是选择类型的一些经验准则:
当明确知晓数值不可能为负时，选用无符导类型。使用int执行整数运算。在实际应用中，short常常显得太小而1ong一般和int有一样的尺寸。如果你的数值超过了int的表示范围，选用1onglong。在算术表达式中不要使用char或boo1，只有在存放字符或布尔值时才使用它们。因为类型char在一些机器上是有符号的，而在另一些机器上又是无符号的所以如果使用char进行运算特别容易出问题。如果你需要使用一个不大的整数那么明确指定它的类型是signed char或者unsigned char。
执行浮点数运算选用double，这是因为f1oat通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。事实上，对于某些机器来说，双精度运算甚至比单精度还快。1ongdouble提供的精度在一般情况下是没有必要的，况且它带来的运行时消耗也不容忽视。
:::

::: tip 建议:避免无法预知和依赖于实现环境的行为
无法预知的行为源于编译器无须(有时是不能)检测的错误。即使代码编译通过了如果程序执行了一条未定义的表达式，仍有可能产生错误。
不幸的是,在某些情况和/或某些编译器下,含有无法预知行为的程序也能正确执行但是我们却无法保证同样一个程序在别的编译器下能正常工作，甚至已经编译通过的代码再次执行也可能会出错。此外，也不能认为这样的程序对一组输入有效，对另一组输入就一定有效。
程序也应该尽量避免依赖于实现环境的行为。如果我们把int的尺寸看成是一个确定不变的已知值，那么这样的程序就称作不可移植的(nonportable)。当程序移植到别的机器上后，依赖于实现环境的程序就可能发生错误。要从过去的代码中定位这类错误可不是一件轻松愉快的工作。
:::

::: tip 提示:切勿混用带符号类型和无符号类型
如果表达式里既有带符号类型又有无符号类型，当带符号类型取值为负时会出现异常结果，这是因为带符号数会自动地转换成无符号数。例如，在一个形如a*b的式子中，如果a--1，b=1，而且a和b都是int，则表达式的值显然为-1。然而，如果a是int，而b是unsigned，则结果须视在当前机器上int所占位数而定。在我们的环境里，结果是4294967295。
:::


::: note 字符和字符串字面值
由单引号括起来的一个字符称为char型字面值，双引号括起来的零个或多个字符则构成字符串型字面值。
```C++
'a'//字符字面值
"Hello World!”//字符串宇面值
```
字符串字面值的类型实际上是由常量字符构成的**数组(aray)**。编译器在每个字符串的结尾处添加一个空字符("\0”)，因此，字符串字面值的实际长度要比它的内容多1。例如，字面值"'表示的就是单独的字符A，而字符串"A"则代表了一个字符的数组，该数组包含两个字符:一个是字母A、另一个是空字符。如果两个字符串字面值位置紧邻且仅由空格、缩进和换行符分隔，则它们实际上是一个整体。当书写的字符串字面值比较长，写在一行里不太合适时，就可以采取分开书写的方式:
```C++
//分多行书写的字符串字面值
std::cout<<"a really,really long string literal "
           "that spans two lines"<< std::endl;
```
:::

### 2.2 变量

::: tip 术语:何为对象?
C++程序员们在很多场合都会使用对象(object)这个名词。通常情况下，对象是指一块能存储数据并具有某种类型的内存空间。
一些人仅在与类有关的场景下才使用“对象”这个词。另一些人则已把命名的对象和未命名的对象区分开来，他们把命名了的对象叫做变量。还有一些人把对象和值区分开来，其中对象指能被程序修改的数据，而值(value)指只读的数据。
本书遵循大多数人的习惯用法，即认为对象是具有某种数据类型的内存空间。我们在使用对象这个词时,并不严格区分是类还是内置类型,也不区分是否命名或是否只读。
:::

::: warning
初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。
:::

::: note
定义于函数体内的内置类型的对象如果没有初始化，则其值未定义。类的对象如果没有显式地初始化，则其值由类确定。
:::

::: tip 提示:未初始化变量引发运行时故障
未初始化的变量含有一个不确定的值，使用未初始化变量的值是一种错误的编程行为并且很难调试。尽管大多数编译器都能对一部分使用未初始化变量的行为提出警告，但严格来说，编译器并未被要求检查此类错误。
使用未初始化的变量将带来无法预计的后果。有时我们足够幸运，一访问此类对象程序就崩溃并报错，此时只要找到崩溃的位置就很容易发现变量没被初始化的问题。另外一些时候，程序会一直执行完并产生错误的结果。更糟糕的情况是，程序结果时对时错、无法把握。而且，往无关的位置添加代码还会导致我们误以为程序对了，其实结果仍旧有错。
建议初始化每一个内置类型的变量。虽然并非必须这么做，但如果我们不能确保初始化后程序安全，那么这么做不失为一种简单可靠的方法。
:::

::: note 变量能且只能被定义一次，但是可以被多次声明。
:::

::: note 声明和定义的区别看起来也许微不足道，但实际上却非常重要。如果要在多个文件中使用同一个变量，就必须将声明和定义分离。此时，变量的定义必须出现在且只能出现在个文件中，而其他用到该变量的文件必须对其进行声明，却绝对不能重复定义。
:::

::: note 关键概念:静态类型
C++是一种静态类型(staticallytyped)语言，其含义是在编译阶段检查类型。其中检查类型的过程称为类型检查(typechecking)
我们已经知道，对象的类型决定了对象所能参与的运算。在C+语言中，编译器负贵检查数据类型是否支持要执行的运算，如果试图执行类型不支持的运算，编译器将报错并且不会生成可执行文件。
程序越复杂，静态类型检查越有助于发现问题。然而，前提是编译器必须知道每一个实体对象的类型，这就要求我们在使用某个变量之前必须声明其类型。
:::

::: tip 建议:当你第一次使用变量时再定义它
一般来说，在对象第一次被使用的地方附近定义它是一种好的选择，因为这样做有助于更容易地找到变量的定义。更重要的是，当变量的定义与它第一次被使用的地方很近时，我们也会赋给它一个比较合理的初始值。
:::

::: warning
如果函数有可能用到某全局变量，则不宜再定义一个同名的局部变量
:::

### 2.3 复合类型

::: note C++11中新增了一种引用:所谓的“右值引用(rvalue reference)”，这种引用主要用于内置类。严格来说当我们使用术语“引用(reference)”时，指的其实是“左值引用(lvalue reference )"
:::

::: note 一般在初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值绑定(bind)在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。
:::

::: note 引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。
:::

::: warning
指针通常难以理解，即使是有经验的程序员也常常因为调试指针引发的错误而被备受折磨。
:::

::: note 解引用操作仅适用于那些确实指向了某个对象的有效指针
:::

::: note 关键概念:某些符号有多重含义
像&和*这样的符号，既能用作表达式里的运算符，也能作为声明的一部分出现，符号的上下文决定了符号的意义:
```C++
int i = 42;
int &r = i; //&紧随类型名出现，因此是声明的一部分，上是一个引用
int *p; //*紧随类型名出现，因此是声明的一部分，P是一个指针
p = &i; //&出现在表达式中，是一个取地址符
*p = i; //*出现在表达式中，是一个解引用符
int &r2 = *p; //&是声明的一部分，*是一个解引用符
```
在声明语句中，&和*用于组成复合类型:在表达式中，它们的角色又转变成运算符。在不同场景下出现的虽然是同一个符号，但是由于含义截然不同，所以我们完全可以把它当作不同的符号来看待。
:::

::: tip 建议:初始化所有指针
使用未经初始化的指针是引发运行时错误的一大原因。
和其他变量一样，访问未经初始化的指针所引发的后果也是无法预计的。通常这一行为将造成程序崩溃，而且一旦崩溃，要想定位到出错位置将是特别棘手的问题。
在大多数编译器环境下，如果使用了未经初始化的指针，则该指针所占内存空问的当前内容将被看作一个地址值。访问该指针，相当于去访问一个本不存在的位置上的本不存在的对象。糟糕的是，如果指针所占内存空间中恰好有内容，而这些内容又被当作了某个地址，我们就很难分清它到底是合法的还是非法的了。
因此建议初始化所有的指针，并且在可能的情况下，尽量等定义了对象之后再定义指向它的指针。如果实在不清楚指针应该指向何处，就把它初始化为nullptr或者0，这样程序就能检测并知道它没有指向任何具体的对象了。
:::

::: warning
很多程序员容易迷惑于基本数据类型和类型修饰符的关系，其实后者不过是声明符的一部分罢了。
:::

::: note
经常有一种观点会误以为，在定义语句中，类型修饰符(*或&)作用于本次定义的全部变量。造成这种错误看法的原因有很多，其中之一是我们可以把空格写在类型修饰符和变量名中间:
```C++
int* p; //合法但是容易产生误导
```
我们说这种写法可能产生误导是因为int*放在一起好像是这条语句中所有变量共同的类型一样。其实恰恰相反，基本数据类型是int而非int*。*仅仅是修饰了p而己，对该声明语句中的其他变量，它并不产生任何作用:
```C++
int* p1，p2; //p1是指向int的指针，P2是int
```
涉及指针或引用的声明，一般有两种写法。第一种把修饰符和变量标识符写在一起:
```C++
int *p1，*p2; //p1和p2 都是指向 int 的指针这种形式着重强调变量具有的复合类型。第二种把修饰符和类型名写在一起，并且每条语句只定义一个变量:
```
这种形式着重强调本次声明定义了一种复合类型。
```C++
int* p1; // p1是指向 int 的指针
int* p2; // p2是指向int的指针
```
上述两种定义指针或引用的不同方法没有孰对孰错之分，关键是选择并坚持其中的一种写法，不要总是变来变去。
:::

::: tip
面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清楚它的真实含义。
:::

### 2.4 const 限定符

::: important
因为const对象一旦创建后其值就不能再改变,所以const对象必须初始化（和引用类似）。
:::

::: note
为了支持这一用法，同时避免对同一变量的重复定义，默认情况下，const对象被设定为仅在文件内有效。当多个文件中出现了同名的 const 变量时，其实等同于在不同文件中分别定义了独立的变量。

::: note
如果想在多个文件之间共享const对象,必须在变量的定义之前添加extern关键字。
:::

::: note 术语:常量引用是对const的引用
C++程序员们经常把词组“对const的引用”简称为“常量引用”，这一简称还是挺靠谱的，不过前提是你得时刻记得这就是个简称而已。
严格来说，并不存在常量引用。因为引用不是一个对象，所以我们没法让引用本身恒定不变。事实上，由于C++语言并不允许随意改变引用所绑定的对象，所以从这层意义上理解所有的引用又都算是常量。引用的对象是常量还是非常量可以决定其所能参与的操作，却无论如何都不会影响到引用和对象的绑定关系本身。
:::

::: tip
试试这样想吧:所谓指向常量的指针或引用，不过是指针或引用“自以为是罢了，它们觉得自己指向了常量，所以自觉地不去改变所指对象的值。
:::


常量指针将一直指向对象，不可改变指向，可以访问对象，可以修改对象的值。
int i = 0;
int *const p = &i;

指针常量



如果你需要判断，可以从右往左读，比如：

int * const p：p 是常量 → 指针常量。指针指向固定，可以改数据。

const int * p：p 指向常量 → 常量指针。数据固定，可以改指向。


int * const p 顶层const
const int * p 底层const

在拷贝时，顶层const一般无所谓，但是如果要操作一个底层const，则一般也需要定义一个const

常量表达式：有const并且具体值已知

::: tip
一般来说，如果你认定变量是一个常量表达式，那就把它声明成constexpr类型。
:::

### 2.5 处理类型

别名声明：
```C++
typedef double db;
db num = 3.14
```
新标准：
```C++
using db = double
db num = 3.14
```

::: note
如果 decltype 使用的是一个不加括号的变量，则得到的结果就是该变量的类型:如果给变量加上了一层或多层括号，编译器就会把它当成是一个表达式。变量是一种可以作为赋值语句左值的特殊表达式，所以这样的 decltype 就会得到引用类型:
```C++
//decltype的表达式如果是加上了括号的变量，结果将是引用
decltype((i))d; //错误：d是int&，必须初始化
decltype(i)e; //正确：e是一个(未初始化的)int
```
:::

::: warning
切记: `decltype((variable))` (注意是双层括号)的结果永远是引用，而 `decltype(variable)` 结果只有当 `variable` 本身就是一个引用时才是引用。
:::

::: warning
很多新手程序员经常忘了在类定义的最后加上分号。
:::


::: note 头文件一旦改变，相关的源文件必须重新编译以获取更新过的声明
:::


::: note C++程序还会用到的一项预处理功能是头文件保护符(header guard)，头文件保护符依赖于预处理变量(参见2.3.2节，第48页)。预处理变量有两种状态:已定义和未定义。#define 指令把一个名字设定为预处理变量，另外两个指令则分别检查某个指定的预处理变量是否已经定义:#ifdef当且仅当变量已定义时为真，#ifndef当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直至遇到#endif指令为止。
:::

::: warning
预处理变量无视C++语言中关于作用域的规则。
:::

::: note 整个程序中的预处理变量包括头文件保护符必须唯一，通常的做法是基于头文件中类的名字来构建保护符的名字，以确保其唯一性。为了避免与程序中的其他实体发生名字冲突，一般把预处理变量的名字全部大写。
:::

::: tip
头文件即使(目前还)没有被包含在任何其他头文件中，也应该设置保护符头文件保护符很简单，程序员只要习惯性地加上就可以了，没必要太在乎你的程序到底需不需要。
:::


## 第 3 章 字符串、向量和数组

### 3.1 命名空间的 using 声明


### 3.2 标准库类型 string

::: note C++标准一方面对库类型所提供的操作做了详细规定，另一方面也对库的实现者做出一些性能上的需求。因此，标准库类型对于一般应用场合来说有足够的效率。
:::

::: note 我们可以清楚地看到在这些初始化方式之间到底有什么区别和联系。如果使用等号(=)初始化一个变量，实际上执行的是拷贝初始化(copy initialization)，编译器把等号右侧的初始值拷贝到新创建的对象中去。与之相反，如果不使用等号，则执行的是直接初始化(direct initialization)。
:::

::: note 触发 `getline` 函数返回的那个换行符实际上被丢弃掉了，得到的 `string` 对象中并不包含该换行符。
:::

::: tip
如果一条表达式中已经有了 `size()` 函数就不要再使用 `int` 了,这样可以避免混用 `int` 和 `unsigned` 可能带来的问题。
:::


::: note
当把 `string` 对象和字符字面值及字符串字面值混在一条语句中使用时,必须确保每个加法运算符(+)的两侧的运算对象至少有一个是 `string` :
```C++
string s4 = sl + ","; //正确:把一个string对象和一个字面值相加
string s5 = "hello" + "，"; //错误:两个运算对象都不是 string

//正确:每个加法运算符都有一个运算对象是string
string s6 = s1 + "，" + "world";
string s7 = "hello" + "，" + s2;//错误:不能把字面值直接相加
```
:::

::: warning
因为某些历史原因，也为了与 C 兼容，所以 C++ 语言中的字符串字面值并不是标准库类型 `string` 的对象。切记，字符串字面值与 `string` 是不同的类型。
:::


::: tip
建议:使用C++版本的C标准库头文件 C++标准库中除了定义C++语言特有的功能外，也兼容了语言的标准库。C语言的头文件形如 name.h，C++则将这些文件命名为cname。也就是去掉了.h后缀，而在文件名 name 之前添加了字母c，这里的c表示这是一个属于C语言标准库的头文件。

因此，cctype 头文件和 ctype.h 头文件的内容是一样的，只不过从命名规范上来讲更符合C++语言的要求。特别的，在名为 cname 的头文件中定义的名字从属于命名空间std，而定义在名为.h的头文件中的则不然。

一般来说，C++程序应该使用名为 cname 的头文件面不使用 name.h 的形式，标准库中的名字总能在命名空间std中找到。如果使用.h形式的头文件，程序员就不得不时刻牢记哪些是从C语言那儿继承过来的，哪些又是C++语言所独有的。
:::

::: note
string 对象的下标必须大于等于 0 而小于 s.size() 。

使用超出此范围的下标将引发不可预知的结果，以此推断，使用下标访问空 string 也会引发不可预知的结果。
:::

::: important
C++是可以直接对string字符串做修改的，这点与python不同。
:::

::: tip 提示:注意检查下标的合法性
使用下标时必须确保其在合理范围之内，也就是说，下标必须大于等于0而小于字符串的size()的值。一种简便易行的方法是，总是设下标的类型为string::size_type，因为此类型是无符号数，可以确保下标不会小于0。此时，代码只需保证下标小于size()的值就可以了。
C++标准并不要求标准库检测下标是否合法。一旦使用了一个超出范围的下标，就会产生不可预知的结果。
:::

### 3.3 标准库类型 vector

::: note
vector 是模板而非类型，由 vector 生成的类型必须包含vector中元素的类型，例如 `vector<int>`。
:::

::: warning
某些编译器可能仍需以老式的声明语句来处理元素为vector的vector对象，如 `vector<vector<int> >`。
:::

::: note 关键概念:vector对象能高效增长
C++标准要求vector应该能在运行时高效快速地添加元素。因此既然vector对象能高效地增长，那么在定义vector对象的时候设定其大小也就没什么必要了，事实上如果这么做性能可能更差。只有一种例外情况，就是所有(all)元素的值都一样。一旦元素的值有所不同，更有效的办法是先定义一个空的vector对象，再在运行时向其中添加具体值。此外，9.4节(第317页)将介绍，vector还提供了方法，允许我们进一步提升动态添加元素的性能。

开始的时候创建空的vector对象,在运行时再动态添加元素，这一做法与C语言及其他大多数语言中内置数组类型的用法不同。特别是如果用惯了C或者Java，可以预计在创建vector对象时顺便指定其容量是最好的。然而事实上，通常的情况是恰恰相反。
:::

::: warning
范围for语句体内不应改变其所遍历序列的大小。
:::

::: note
要使用size type，需首先指定它是由哪种类型定义的。vector 对象的类型总是包含着元素的类型(参见33节，第87页):
```C++
vector<int>::size type // 正确
vector::size type // 错误
```
:::

::: warning
vector 对象(以及string对象)的下标运算符可用于访问已存在的元素，而不能用于添加元素。
:::

::: tip 提示:只能对确知已存在的元素执行下标操作!
关于下标必须明确的一点是:只能对确知已存在的元素执行下标操作。例如，
```C++
vector<int> ivec; //空vector对象
cout << ivec[0]; //错误:ivec 不包含任何元素

vector<int> ivec2(10); //含有10个元素的vector对象
cout << ivec2[10]; //错误:ivec2元素的合法索引是从0到9
```
试图用下标的形式去访问一个不存在的元素将引发错误，不过这种错误不会被编译器发现，而是在运行时产生一个不可预知的值。

不幸的是，这种通过下标访问不存在的元素的行为非常常见，而且会产生很严重的后果。所谓的缓冲区溢出(bufer overflow)指的就是这类错误，这也是导致PC及其他设备上应用程序出现安全问题的一个重要原因。

确保下标合法的一种有效手段就是尽可能使用范围for语句。
:::

### 3.4 迭代器介绍

::: note
如果容器为空，则begin和end返回的是同一个迭代器，都是尾后迭代器。
:::

::: note
因为 end 返回的迭代器并不实际指示某个元素，所以不能对其进行递增或解引用的操作。
:::

::: note 关键概念:泛型编程
原来使用C或Java的程序员在转而使用++语言之后，会对for循环中使用!-而非<进行判断有点儿奇怪，比如上面的这个程序以及85页的那个。C++程序员习惯性地使用!-，其原因和他们更愿意使用迭代器而非下标的原因一样:因为这种编程风格在标准库提供的所有容器上都有效。

之前已经说过，只有string和vector等一些标准库类型有下标运算符，而并非全都如此。与之类似，所有标准库容器的选代器都定义了--和!，但是它们中的大多数都没有定义<运算符。因此，只要我们养成使用选代器和!-的习惯，就不用太在意用的到底是哪种容器类型。
:::

::: note 术语:迭代器和迭代器类型
迭代器这个名词有三种不同的含义:可能是选代器概念本身，也可能是指容器定义的选代器类型，还可能是指某个选代器对象。
重点是理解存在一组概念上相关的类型，我们认定某个类型是迭代器当且仅当它支持一套操作，这套操作使得我们能访问容器的元素或者从某个元素移动到另外一个元素。每个容器类定义了一个名为iterator的类型，该类型支持选代器概念所规定的一套操作。
:::

::: note 术语:迭代器和迭代器类型
注意，(*it).empty()中的圆括号必不可少，具体原因将在4.1.2节(第121页)介绍，该表达式的含义是先对it解引用，然后解引用的结果再执行点运算符(参见1.5.2节，第20页)。如果不加圆括号，点运算符将由it来执行，而非it解引用的结果:
```C++
(*it).empty() //解引用it，然后调用结果对象的empty成员
*it.empty() //错误:试图访问it的名为empty的成员，但it是个迭代器,没有empty成员
```
上面第二个表达式的含义是从名为it的对象中寻找其empty成员，显然 it是一个迭代器，它没有哪个成员是叫empty的，所以第二个表达式将发生错误。
为了简化上述表达式，C++语言定义了箭头运算符(->)。箭头运算符把解引用和成员访问两个操作结合在一起，也就是说，it->mem和(*it).mem表达的意思相同。
:::

::: warning
谨记，但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素。
:::

::: note
只要两个迭代器指向的是同一个容器中的元素或者尾元素的下一位置，就能将其相减，所得结果是两个迭代器的距离。所谓距离指的是右侧的迭代器向前移动多少位置就能追上左侧的迭代器，其类型是名为 difference_type 的带符号整型数。string和vector 都定义了 difference_type，因为这个距离可正可负，所以 difference_type 是带符号类型的。
:::

### 3.5 数组

::: tip
如果不清楚元素的确切个数，请使用vector。
:::

::: warning
和内置类型的变量一样，如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。
:::

::: note 定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值的列表推断类型。另外和vector一样，数组的元素应为对象，因此不存在引用的数组。
:::

::: note
```C++
const char a4[6]="Daniel"; //错误:没有空间可存放空字符!
```
尽管字符串字面值"Daniel"看起来只有6个字符，但是数组的大小必须至少是7，其中6个位置存放字面值的内容，另外1个存放结尾处的空字符。
:::

::: warning
不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值。一些编译器支持数组的赋值，这就是所谓的编译器扩展(compiler extension)。但一般来说，最好避免使用非标准特性，因为含有非标准特性的程序很可能在其他编译器上无法正常工作。
:::




### 3.6 多维数组