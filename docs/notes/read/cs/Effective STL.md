---
title: '《Effective STL》'
createTime: 2025/09/04 20:33:17
permalink: /read/qbo8t3dv/
badge:
  type: tip
  text: 新
---

<p align="center">
  <img src="https://t15.baidu.com/it/u=1916742412,933389634&fm=224&app=112&f=JPEG?w=500&h=500
  " width="300"><br>
  <b>《Effective STL》 - [美] Scott Meyers</b>
</p>

<LinkCard title="Z-Library: 《中文版Effective STL:50条有效使用STL的经验 (技术经典著作大系)》" href="https://zh.z-lib.gd/book/17815085/07eda0/%E4%B8%AD%E6%96%87%E7%89%88effective-stl50%E6%9D%A1%E6%9C%89%E6%95%88%E4%BD%BF%E7%94%A8stl%E7%9A%84%E7%BB%8F%E9%AA%8C-%E6%8A%80%E6%9C%AF%E7%BB%8F%E5%85%B8%E8%91%97%E4%BD%9C%E5%A4%A7%E7%B3%BB.html"/>


## 引言

>你已经熟悉STL了。你知道怎样创建容器、怎样遍历容器中的内容，知道怎样添加和删除元素，以及如何使用常见的算法，比如find和sort。但是你并不满意。你总是感到自己还不能充分地利用STL。本该很简单的任务却并不简单；本该很直接的操作却要么泄漏资源，要么结果不对；本该更有效的过程却需要更多的时间或内存，超出了你的预期。是的，你已经知道如何使用STL了，但是你并不能确定自己是否在有效地使用它。

>本书中的信息将会使你成为一位更优秀的STL程序员；它会使你成为一位高效率、高产出的程序员；它还会使你成为一位快乐的程序员。使用STL很令人开心，但是有效地使用它则令人更开心，这种开心来源于它会使你有更多的时间离开键盘，因为你可能不相信自己会节省这么多时间。即便是对STL粗略浏览一遍，也能发现这是一个非常酷的库，但你可能想象不到实际上它还要酷得多（无论是深度还是广度）。本书的一个主要目标是向你展示这个库是多么令人惊奇，因为在我从事程序设计近三十年来，我从来没看到过可以与STL相媲美的代码库。可能你也没见过。

## 定义、使用和扩展STL

::: note STL之所以存在扩展，其中一个原因是，STL的设计目的就是为了便于扩展。但在本书中，我将把焦点放在如何使用STL上，而不是如何向其中添加新的部件。比如，你会发现，我将很少讲述如何编写自己的算法，对于如何编写新的容器和迭代器也没有给出任何建议。我相信，在考虑增强STL的能力之前，首先重要的是掌握STL已经提供了什么，而这正是本书的焦点所在。
:::

## 术语，术语，术语

::: note vector、string、deque 和 list 被称为标准序列容器。标准关联容器是 set、multiset、map 和 multimap。
:::

::: note
根据迭代器所支持的操作，可以把迭代器分为五类。简单来说，输入迭代器（input iterator）是只读迭代器，在每个被遍历到的位置上只能被读取一次。输出迭代器（output iterator）是只写迭代器，在每个被遍历到的位置上只能被写入一次。输入和输出迭代器的模型分别是建立在针对输入和输出流（例如文件）的读写操作的基础上的。所以不难理解，输入和输出迭代器最常见的表现形式是istream_iterator和ostream_iterator。

前向迭代器 （forward iterator）兼具输入和输出迭代器的能力，但是它可以对同一个位置重复进行读和写。前向迭代器不支持operator--，所以它只能向前移动。所有的标准STL容器都支持比前向迭代器功能更强大的迭代器，但是，你在第25条中可以看到，散列容器的一种设计会产生前向迭代器。单向链表容器（见第50条）也提供了前向迭代器。

双向迭代器 （bidirectional iterator）很像前向迭代器，只是它们向后移动和向前移动同样容易。标准关联容器都提供了双向迭代器。list也是如此。

随机访问迭代器 （random access iterator）有双向迭代器的所有功能，而且，它还提供了“迭代器算术”，即向前或向后跳跃一步的能力。vector、string和deque都提供了随机访问迭代器。指向数组内部的指针对于数组来说也是随机访问迭代器。
:::

::: note 所有重载了函数调用操作符（即operator()）的类都是一个函数子类（functor class）。从这些类创建的对象被称为函数对象（function object）或函数子（functor）。在STL中，大多数使用函数对象的地方同样也可以使用实际的函数，所以我经常使用“函数对象”（function object）这个术语既表示C++函数，也表示真正的函数对象。
:::

::: note 函数bind1st和bind2nd被称为绑定器（binder）。
:::

## 第1章 容器

### 第1条：慎重选择容器类型。

::: note
- 标准STL序列容器 ：vector、string、deque和list。

- 标准STL关联容器 ：set、multiset、map和multimap。

- 非标准序列容器slist和rope 。slist是一个单向链表，rope本质上是一“重型”string。（“rope”是重型“string”，明白了吗？）你可以在第50条中找到对这些非标准（但通常可以使用）的容器的一个简要介绍。

- 非标准关联容器hash_set、hash_multiset、hash_map和hash_multimap 。在第25条中，我分析了这些基于散列表的、标准关联容器的变体（它们通常是广泛可用的）。

- `vector<char>` 作为string的替代 。第13条讲述了在何种条件下这种替代是有意义的。

- vector作为标准关联容器的替代 。正如第23条中所阐明的，有时vector在运行时间和空间上都要优于标准关联容器。

- 几种标准的非STL容器 ，包括数组、bitset、valarray、stack、queue和priority_queue。因为它们不是STL容器，所以在本书中很少提及，仅在第16条中提到了一种“数组优于STL容器”的情形，以及在第18条中解释了为什么bitset比`vector<bool>`要好。值得记住的是，数组也可以被用于STL算法，因为指针可以被用作数组的迭代器。
:::

::: tip
对于容器，STL给了你多种选择。在STL以外，你还有更多的选择。在选择一个容器之前，请仔细考虑所有的选择。存在“默认的容器”吗？我可不这样认为。
:::

### 第2条：不要试图编写独立于容器类型的代码。

::: note 即便是最热心地倡导独立于容器类型的代码的人也很快会意识到，试图编写对序列容器和关联容器都适用的代码几乎是毫无意义的。很多成员函数仅当其容器为某一种类型时才存在，例如，只有序列容器才支持push_front或push_back，只有关联容器才支持count和lower_bound，等等。即使是insert和erase这样的基本操作，也会随容器类型的不同而表现出不同的原型和语义。
:::

::: note 面对现实吧：这么做不值得。不同的容器是不同的，它们有非常明显的优缺点。
:::

::: note 它们并不是被设计来交换使用的，你无法掩盖这一点。如果你试图这样做，你只是在碰运气，而这种运气却是碰不到的。
:::

### 第3条：确保容器中的对象副本正确而高效。

::: note 容器中保存了对象，但并不是你提供给容器的那些对象。而当从容器中取出一个对象时，你所取出的也并不是容器中所保存的那份。当向容器中加入对象时（通过如insert或push_back之类的操作），存入容器的是你所指定的对象的副本。当（通过如front或back之类的操作）从容器中取出一个对象时，你所得到的是容器中所保存的对象的副本。进去的是副本，出来的也是副本（copy in，copy out）。这就是STL的工作方式。
:::

::: note 当然，在存在继承关系的情况下，复制动作会导致剥离（slicing）。也就是说，如果你创建了一个存放基类对象的容器，却向其中插入派生类的对象，那么在派生类对象（通过基类的复制构造函数）被复制进容器时，它所特有的部分（即派生类中的信息）将会丢失。“剥离”问题意味着向基类对象的容器中插入派生类对象几乎总是错误的。如果你希望插入后的对象仍然表现得像派生类对象一样，例如调用派生类的虚函数等，那么这种期望是错误的。
:::

::: note 使复制动作高效、正确，并防止剥离问题发生的一个简单办法是使容器包含指针而不是对象。也就是说，使用Widget* 的容器，而不是Widget的容器。复制指针的速度非常快，并且总是会按你期望的方式进行（它复制构成指针的每一位），而且当它被复制时不会有任何剥离现象发生。不幸的是，指针的容器也有其自身的一些令人头疼的、与STL相关的问题。你可以参考第7条和第33条。如果你想避开这些使人头疼的问题，同时又想避免效率、正确性和剥离这些问题，你可能会发现智能指针（smart pointer）是一个诱人的选择。要想了解更多关于这种选择的知识，请参阅第7条。
:::

::: tip
与数组相比，STL容器要聪明得多。你让它创建多少对象，它就（通过复制）创建多少对象，不会多，也不会少。你让它创建时它才创建，只有当你让它使用默认构造函数时它才会使用。没错，STL容器是在创建副本；确实是这样的，你需要明白这一点。但是，跟数组相比，它们仍是迈出了一大步。这是一个不可忽略的事实
:::

### 第4条：调用empty而不是检查size()是否为0。

::: note 对任一容器c，下面的代码 `if(c.size()== 0)` 本质上与 `if (c.empty())` 是等价的。既然如此，你或许会疑惑为什么要偏向于某一种形式，尤其是考虑到empty通常被实现为内联函数（inline function），并且它所做的仅仅是返回size是否为0。
:::

::: note 你应该使用empty形式，理由很简单：empty对所有的标准容器都是常数时间操作，而对一些list实现，size耗费线性时间。
:::

::: tip
不管发生了什么，调用empty而不是检查size==0是否成立总是没错的。所以，如果你想知道容器中是否含有零个元素，请调用empty。
:::

### 第5条：区间成员函数优先于与之对应的单元素成员函数。

::: note 设计该小测验的第二个目的是为了揭示为什么区间成员函数（range member function）优先于与之对应的单元素成员函数。区间成员函数是指这样的一类成员函数，它们像STL算法一样，使用两个迭代器参数来确定该成员操作所执行的区间。如果不使用区间成员函数来解决本条款开篇时提出的问题，你就得写一个显式的循环。
:::

::: note 太多的STL程序员滥用了copy，所以我刚才给出的建议值得再重复一下：通过利用插入迭代器的方式来限定目标区间的copy调用，几乎都应该被替换为对区间成员函数的调用。
:::

::: note
现在回到assign的例子。我们已经给出了使用区间成员函数而不是其相应的单元素成员函数的原因：

- 通过使用区间成员函数，通常可以少写一些代码。

- 使用区间成员函数通常会得到意图清晰和更加直接的代码。
:::

::: note 效率分析
第一种影响是不必要的函数调用。把numValues个元素逐个插入到v中导致了对insert的numValues次调用。而使用区间形式的insert，则只做了一次函数调用，节省了numValues－1次。当然，使用内联（inlining）可能会避免这样的影响，但是，实际中不见得会使用内联。只有一点是肯定的：使用区间形式的insert，肯定不会有这样的影响。

内联无法避免第二种影响，即把v中已有的元素频繁地移动到插入后它们所处的位置。每次调用insert把新元素插入到v中时，插入点后的每个元素都要向后移动一个位置，以便为新元素腾出空间。所以，位置p的元素必须被移动到位置p＋l，等等。在我们的例子中，我们向v的前端插入numValues个元素，这意味着v中插入点之后的每个元素都要向后移动numValues个位置。每次调用insert时，每个元素需向后移动一个位置，所以每个元素将移动numValues次。如果插入前v中有n个元素，就会有n* numValues次移动。在这个例子中，v中存储的是int类型，每次移动最终可能会归为调用memmove，可是如果v中存储的是Widget这样的用户自定义类型，则每次移动会导致调用该类型的赋值操作符或复制构造函数。（大多数情况下会调用赋值操作符，但每次vector中的最后一个元素被移动时，将会调用该元素的复制构造函数。）所以在通常情况下，把numValues个元素逐个插入到含有n个元素的`vector<Widget>`的前端将会有n* numValues次函数调用的代价：(n－1)* numValues次调用Widget的赋值操作符和numValues次调用Widget的复制构造函数。即使这些调用是内联的，你仍然需要把v中的元素移动numValues次。

与此不同的是，C++标准要求区间insert函数把现有容器中的元素直接移动到它们最终的位置上，即只需付出每个元素移动一次的代价。总的代价包括n次移动、numValues次调用该容器中元素类型的复制构造函数，以及调用该类型的赋值操作符。同每次插入一个元素的策略相比较，区间insert减少了n* (numValues－1)次移动。细算下来，这意味着如果numValues是100，那么区间形式的insert比重复调用单元素形式的insert减少了99％的移动。

在讲述单元素形式的成员函数和与其对应的区间成员函数相比较所存在的第三个效率问题之前，我需要做一个小小的更正。我在前面的段落中所写的是对的，的确是对的，但并不总是对的。区间insert函数仅当能确定两个迭代器之间的距离而不会失去它们的位置时，才可以一次就把元素移动到其最终位置上。这几乎总是可能的，因为所有的前向迭代器都提供了这样的功能，而前向迭代器几乎无处不在。标准容器的所有迭代器都提供了前向迭代器的功能。非标准散列容器的迭代器也是如此（见第25条）。指针作为数组的迭代器也提供了这一功能。实际上，不提供这一功能的标准迭代器仅有输入和输出迭代器。所以，我所说的是正确的，除非传入区间形式insert的是输入迭代器（如istream_iterator，见第6条）。仅在这样的情况下，区间insert也必须把元素一步步移动到其最终位置上，因而它的优势就丧失了。（对于输出迭代器不会产生这个问题，因为输出迭代器不能用来标明一个区间。）

不明智地使用重复的单元素插入操作而不是一次区间插入操作，这样所带来的最后一个性能问题跟内存分配有关，尽管它同时还伴有讨厌的复制问题。在第14条将会指出，如果试图把一个元素插入到vector中，而它的内存已满，那么vector将分配具有更大容量（capacity）的新内存，把它的元素从旧内存复制到新内存中，销毁旧内存中的元素，并释放旧内存。然后它把要插入的元素加入进来。第14条还解释了多数vector实现每次在内存耗尽时，会把容量加倍，因此，插入numValues个新元素最多可导致`log<sub>2</sub>numValues`次新的内存分配。第14条指出，表现出这种行为的vector实现是存在的，因此，把1000个元素逐个插入可能会导致10次新的内存分配（包括低效的元素复制）。与之对应（而且，到现在为止也可以预见），使用区间插入的方法，在开始插入前可以知道自己需要多少新内存（假定给它的是前向迭代器），所以不必多次重新分配vector的内存。可以想见，这一节省是很可观的。
:::


::: tip
现在你明白了，优先选择区间成员函数而不是其对应的单元素成员函数有三条充分的理由：区间成员函数写起来更容易，更能清楚地表达你的意图，而且它们表现出了更高的效率。这是很难被打败的三驾马车。
:::

### 第6条：当心C++编译器最烦人的分析机制。

::: note
```C++
list<int> data(istream iterator<int>(dataFile), istream_iterator<int>()); //小心!结果不会是你所想象的那样
```
请你注意了。这声明了一个函数data，其返回值是`list<int>`。这个data函数有两个参数：

- 第一个参数的名称是dataFile。它的类型是`istream_iterator<int>`。dataFile两边的括号是多余的，会被忽略。

- 第二个参数没有名称。它的类型是指向不带参数的函数的指针，该函数返回一个`istream_iterator<int>`。

这令人吃惊，对吧？但它却与C++中的一条普遍规律相符，即尽可能地解释为函数声明。
:::

::: note
所有这些都很有意思（通过它自己的歪曲的方式），但这并不能帮助我们做自己想做的事情。我们想用文件的内容初始化`list<int>`对象。现在我们已经知道必须绕过某一种分析机制，剩下的事情就简单了。把形式参数的声明用括号括起来是非法的，但给函数参数加上括号却是合法的，所以通过增加一对括号，我们强迫编译器按我们的方式来工作：
```C++
list<int> data((istream iterator<int>(dataFile)), istream_iterator<int>()); //注意list构造函数的第一参数两边的括号
```
:::

::: note
更好的方式是在对data的声明中避免使用匿名的istream_iterator对象（尽管使用匿名对象是一种趋势），而是给这些迭代器一个名称。下面的代码应该总是可以工作的：
```C++
ifstream dataFile("ints.dat");
istream_iterator<int> dataBegin(dataFile);
istream_iterator<int> dataEnd;
list<int> data(dataBegin, dataEnd);
```
:::

::: tip
使用命名的迭代器对象与通常的STL程序风格相违背，但你或许觉得为了使代码对所有编译器都没有二义性，并且使维护代码的人理解起来更容易，这一代价是值得的。
:::

### 第7条：如果容器中包含了通过new操作创建的指针，切记在容器对象析构前将指针delete掉。

::: note STL中的容器相当“聪明”。它们提供了迭代器，以便进行向后和向前的遍历（通过begin、end、rbegin等）；它们告诉你所包含的元素类型（通过它们的value_type类型定义）；在插入和删除的过程中，它们自己进行必要的内存管理；它们报告自己有多少对象，最多能容纳多少对象（分别通过size和max_size）；当然，当它们自身被析构时，它们自动析构所包含的每个对象。
:::

::: note 有了这么“聪明”的容器，许多程序员不再考虑自己做善后清理工作。更糟的是，他们认为，容器会考虑为他们做这些事情。很多情况下，他们是对的。但当容器包含的是通过new的方式而分配的指针时，他们这么想就不正确了。没错，指针容器在自己被析构时会析构所包含的每个元素，但指针的“析构函数”不做任何事情！它当然也不会调用delete。
:::

::: tip
- 永远都不要错误地认为：你可以通过创建auto_ptr的容器使指针被自动删除。这个想法很可怕，也很危险。我将在第8条中解释为什么你应该避免这样做。

- 你所要记住的是：STL容器很智能，但没有智能到知道是否该删除自己所包含的指针的程度。当你使用指针的容器，而其中的指针应该被删除时，为了避免资源泄漏，你必须或者用引用计数形式的智能指针对象（比如Boost的shared_ptr）代替指针，或者当容器被析构时手工删除其中的每个指针。

- 最后，可能你会想到，既然像DeleteObject这样的结构能使指针容器（其中的指针指向有效的对象）避免资源泄漏更加容易，那么，创建一个类似的DeleteArray结构，对于元素为指向数组的指针的容器，使它们避免资源泄漏也应该是可能的。这当然是可能的，但是否可取则是另一回事。第13条解释了为什么动态分配的数组几乎总是不如vector和string对象。所以在坐下来写DeleteArray前，先看看第13条。或许你会发现你永远也不会用到DeleteArray结构。
:::

### 第8条：切勿创建包含auto_ptr的容器对象。

::: note 现在我先说它的一个缺点。理解这一缺点不需要auto_ptr的知识，甚至不需要容器的知识：COAP是不可移植的。它怎么可以移植呢？C++标准都禁止它，好的STL平台已经做到了这一点。有理由相信，随着时间的推进，现在没有在这一点上支持标准的STL平台将会变得更加符合标准，那时，使用COAP的代码将变得比现在更加不可移植。如果你看重可移植性（你应该这样），就应该放弃COAP，因为它们不能通过可移植性测试。
:::

::: note 或许你对可移植性不太关心。如果是这样，那我就告诉你复制auto_ptr意味着什么，这会很特别——有些人会说很古怪。当你复制一个auto_ptr时，它所指向的对象的所有权被移交到拷入的auto_ptr上，而它自身被置为NULL。你理解得对，复制一个auto_ptr意味着改变它的值。
:::

::: tip
如果你的目标是包含智能指针的容器，这并不意味着你要倒霉。包含智能指针的容器是没有问题的，第50条中会指出你能找到在STL容器中工作得很好的智能指针。问题的根源只是在于auto_ptr不是这样的智能指针。它根本就不是！
:::

### 第9条：慎重选择删除元素的方法。

::: note
如果你有一个连续内存的容器（vector、deque或string——见第1条），那么最好的办法是使用erase-remove习惯用法（见第32条）：
```C++
c.erase(remove(c.begin(), c.end(), 1963), c.end()); //当c是vector、string或deque时，erase-remove习惯用法是删除特定值的元素的最好办法
```
对list，这一办法同样适用。但正如第44条所指出的，list的成员函数remove更加有效：
```C++
c.remove(1963); //当c是list时，remove成员函数//是删除特定值的元素的最好办法。
```
当c是标准关联容器（例如set、multiset、map或multimap）时，使用任何名为remove的操作都是完全错误的。这样的容器没有名为remove的成员函数，使用remove算法可能会覆盖容器的值（见第32条），同时可能会破坏容器。（细节请参考第22条，那里解释了为什么试图对map和multimap使用remove不能编译，而试图对set和multiset使用remove时可能编译通不过。）

对于关联容器，解决问题的正确方法是调用erase：
```C++
c.erase(1963); //当c是标准关联容器时，erase成员函数是删除特定值元素的最好办法。
```
这样做不仅是正确的，而且是高效的，只需要对数时间开销。（对序列容器的基于remove的技术需要线性时间。）而且，关联容器的erase成员函数还有另外一个优点，即它是基于等价（equivalence）而不是相等（equality）的，这一区别的重要性将在第19条中解释。
:::

::: note 现在给我们带来麻烦的是vector、string和deque。我们不能再使用erase-remove习惯用法了，因为没办法使erase或remove向日志文件中写信息。而且我们不能使用刚才为关联容器设计的循环，因为对vector、string和deque，它会导致不确定的行为！记住，对这类容器，调用erase不仅会使指向被删除元素的迭代器无效，也会使被删除元素之后的所有迭代器都无效。在我们的例子中，这包括i之后的所有迭代器。采用i++、++i或你所能想象得出的其他形式都无济于事，因为它们都会导致迭代器无效。
:::

::: tip
要删除容器中有特定值的所有对象：

如果容器是vector、string或deque，则使用erase-remove习惯用法。

- 如果容器是list，则使用list::remove。

- 如果容器是一个标准关联容器，则使用它的erase成员函数。

- 要删除容器中满足特定判别式（条件）的所有对象：

    1. 如果容器是vector、string或deque，则使用erase-remove_if习惯用法。

    2. 如果容器是list，则使用list::remove_if。

    3. 如果容器是一个标准关联容器，则使用remove_copy_if和swap，或者写一个循环来遍历容器中的元素，记住当把迭代器传给erase时，要对它进行后缀递增。

- 要在循环内部做某些（除了删除对象之外的）操作：

    1. 如果容器是一个标准序列容器，则写一个循环来遍历容器中的元素，记住每次调用erase时，要用它的返回值更新迭代器。

    2. 如果容器是一个标准关联容器，则写一个循环来遍历容器中的元素，记住当把迭代器传给erase时，要对迭代器做后缀递增。
:::

### 第10条：了解分配子（allocator）的约定和限制。

::: tip
乌拉！我们对分配子特性的研究终于结束了。现在让我们总结一下如果你希望编写自定义的分配子，都需要记住哪些内容：

- 你的分配子是一个模板，模板参数T代表你为它分配内存的对象的类型。

- 提供类型定义pointer和reference，但是始终让pointer为T* ，reference为T&。

- 千万别让你的分配子拥有随对象而不同的状态（per-object state）。通常，分配子不应该有非静态的数据成员。

- 记住，传给分配子的allocate成员函数的是那些要求内存的对象的个数，而不是所需的字节数。同时要记住，这些函数返回T* 指针（通过pointer类型定义），即使尚未有T对象被构造出来。

- 一定要提供嵌套的rebind模板，因为标准容器依赖该模板。
:::

### 第11条：理解自定义分配子的合理用法。

::: tip
正如这些例子所显示的，分配子在许多场合下都非常有用。只要你遵守了同一类型的分配子必须是等价的这一限制要求，那么，当你使用自定义的分配子来控制通用的内存管理策略的时候，或者在聚集成员关系的时候，或者在使用共享内存和其他特殊堆的时候，就不会陷入麻烦。
:::

### 第12条：切勿对STL容器的线程安全性有不切实际的依赖。

::: note 因为Lock对象在其析构函数中释放容器的互斥体，所以很重要的一点是，当互斥体应该被释放时Lock就要被析构。为了做到这一点，我们创建了一个新的代码块（block），在其中定义了Lock，当不再需要互斥体时就结束该代码块。看起来好像是我们把“调用releaseMutexFor”这一任务换成了“结束代码块”，事实上这种说法是不确切的。如果我们忘了为Lock创建新的代码块，则互斥体仍然会被释放，只不过会晚一些——当控制到达包含Lock的代码块末尾时。而如果我们忘记了调用releaseMutexFor，那么我们永远也不会释放互斥体。
:::

::: note 而且，基于Lock的方案在有异常发生时也是强壮的。C++保证，如果有异常被抛出，局部对象会被析构，所以，即便在我们使用Lock对象的过程中有异常抛出，Lock仍会释放它所拥有的互斥体（已经证实存在一个漏洞。如果根本没有捕获异常，那么程序将终止。在这种情况下，局部对象（如lock）可能还没有调用它们的析构函数。有些编译器会这样，有些编译器不会这样，这两种情况都是有效的） 。如果我们依赖于手工调用getMutexFor和releaseMutexFor，那么，当在调用getMutexFor之后而在调用releaseMutexFor之前有异常被抛出时，我们将永远也无法释放互斥体。
:::

::: tip
异常和资源管理虽然很重要，但它们不是本条款的主题。本条款是讲述STL中的线程安全性的。当涉及STL容器和线程安全性时，你可以指望一个STL库允许多个线程同时读一个容器，以及多个线程对不同的容器做写入操作。你不能指望STL库会把你从手工同步控制中解脱出来，而且你不能依赖于任何线程支持。
:::

## 第2章　vector和string

### 第13条：vector和string优先于动态分配的数组。

::: note 每次当你发现自己要动态地分配一个数组时（例如想写"`new T[...]`"时），你都应该考虑用vector和string来代替。（一般情况下，当T是字符类型时用string，否则用vector。不过在本条款中，我们还会见到一种特殊的情形，在这种情形下，`vector<char>`可能是一种更为合理的选择。）vector和string消除了上述的负担，因为它们自己管理内存。当元素被加入到容器中时，它们的内存会增长；而当vector或string被析构时，它们的析构函数会自动析构容器中的元素并释放包含这些元素的内存。
:::

::: tip
总结起来很简单，如果你正在动态地分配数组，那么你可能要做更多的工作。为了减轻自己的负担，请使用vector或string。
:::

### 第14条：使用reserve来避免不必要的重新分配。

::: note
reserve成员函数能使你把重新分配的次数减少到最低限度，从而避免了重新分配和指针／迭代器／引用失效带来的开销。但是，在解释reserve怎样做到这一点之前，我将简单概括一下4个相互关联，但有时会被混淆的成员函数。在标准容器中，只有vector和string提供了所有这4个函数。

- size()告诉你该容器中有多少个元素。它不会告诉你该容器为自己所包含的元素分配了多少内存。

- capacity()告诉你该容器利用已经分配的内存可以容纳多少个元素。这是容器所能容纳的元素总数，而不是它还能容纳多少个元素。如果你想知道一个vector有多少未被使用的内存，你就得从capacity()中减去size()。如果size和capacity返回同样的值，就说明容器中不再有剩余空间了，因此下一个插入操作（通过insert或push_back等）将导致上面所讲过的重新分配过程。

- resize(Container::size_type n)强迫容器改变到包含n个元素的状态。在调用resize之后，size将返回n。如果n比当前的大小（size）要小，则容器尾部的元素将会被析构。如果n比当前的大小要大，则通过默认构造函数创建的新元素将被添加到容器的末尾。如果n比当前的容量要大，那么在添加元素之前，将先重新分配内存。

- reserve(Container::size_type n)强迫容器把它的容量变为至少是n，前提是n不小于当前的大小。这通常会导致重新分配，因为容量需要增加。（如果n比当前的容量小，则vector忽略该调用，什么也不做；而string则可能把自己的容量减为size()和n中的最大值，但是string的大小肯定保持不变。以我的经验，使用reserve从string中除去多余的容量通常不如使用“swap技巧”。“swap技巧”是第17条的主题。）
:::

::: tip
回到本条款的要点上。通常有两种方式来使用reserve以避免不必要的重新分配。第一种方式是，若能确切知道或大致预计容器中最终会有多少元素，则此时可使用reserve。在这种情况下，就像上面代码中的vector一样，你可以简单地预留适当大小的空间。第二种方式是，先预留足够大的空间（根据你的需要而定），然后，当把所有数据都加入以后，再去除多余的容量。要去除多余部分并不困难，但在这里我不想指出如何做，因为这其中有一个诀窍。要想学习这个诀窍，请参阅第17条。
:::

### 第15条：注意string实现的多样性。

::: note
很明显，string的实现比乍看上去有更多的自由度；同样明显的是，不同的实现以不同的方式利用了这种设计上的灵活性。这些区别总结如下：

- string的值可能会被引用计数，也可能不会。很多实现在默认情况下会使用引用计数，但它们通常提供了关闭默认选择的方法，往往是通过预处理宏来做到这一点。第13条给出了你想将其关闭的一种特殊情况，但其他的原因也可能会让你这样做。比如，只有当字符串被频繁复制时，引用计数才有用，而有些应用并不经常复制内存，这就不值得使用引用计数了。

- string对象大小的范围可以是一个char* 指针的大小的1倍到7倍。

- 创建一个新的字符串值可能需要零次、一次或两次动态分配内存。

- string对象可能共享，也可能不共享其大小和容量信息。

- string可能支持，也可能不支持针对单个对象的分配子。

- 不同的实现对字符内存的最小分配单位有不同的策略。
:::

::: tip
请不要误解我的意思。我认为string是标准库中最重要的部分之一，我鼓励你多使用它。比如，第13条就是讲述为什么你应该使用string来代替动态分配的字符数组。同时，如果你想有效地使用STL，那么，你需要知道string实现的多样性，尤其是当你编写的代码必须要在不同的STL平台上运行而你又面临着严格的性能要求的时候。而且，string看起来是这么简单，而谁又能想到它的实现会这么有趣呢？
:::
