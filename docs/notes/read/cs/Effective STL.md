---
title: 《Effective STL》——在读
createTime: 2025/09/04 20:33:17
permalink: /read/qbo8t3dv/
---

<p align="center">
  <img src="https://t15.baidu.com/it/u=1916742412,933389634&fm=224&app=112&f=JPEG?w=500&h=500
  " width="300"><br>
  <b>《Effective STL》 - [美] Scott Meyers</b>
</p>

<LinkCard title="Z-Library: 《中文版Effective STL:50条有效使用STL的经验 (技术经典著作大系)》" href="https://zh.z-lib.gd/book/17815085/07eda0/%E4%B8%AD%E6%96%87%E7%89%88effective-stl50%E6%9D%A1%E6%9C%89%E6%95%88%E4%BD%BF%E7%94%A8stl%E7%9A%84%E7%BB%8F%E9%AA%8C-%E6%8A%80%E6%9C%AF%E7%BB%8F%E5%85%B8%E8%91%97%E4%BD%9C%E5%A4%A7%E7%B3%BB.html"/>


## 引言

>你已经熟悉STL了。你知道怎样创建容器、怎样遍历容器中的内容，知道怎样添加和删除元素，以及如何使用常见的算法，比如find和sort。但是你并不满意。你总是感到自己还不能充分地利用STL。本该很简单的任务却并不简单；本该很直接的操作却要么泄漏资源，要么结果不对；本该更有效的过程却需要更多的时间或内存，超出了你的预期。是的，你已经知道如何使用STL了，但是你并不能确定自己是否在有效地使用它。

>本书中的信息将会使你成为一位更优秀的STL程序员；它会使你成为一位高效率、高产出的程序员；它还会使你成为一位快乐的程序员。使用STL很令人开心，但是有效地使用它则令人更开心，这种开心来源于它会使你有更多的时间离开键盘，因为你可能不相信自己会节省这么多时间。即便是对STL粗略浏览一遍，也能发现这是一个非常酷的库，但你可能想象不到实际上它还要酷得多（无论是深度还是广度）。本书的一个主要目标是向你展示这个库是多么令人惊奇，因为在我从事程序设计近三十年来，我从来没看到过可以与STL相媲美的代码库。可能你也没见过。

## 定义、使用和扩展STL

::: note STL之所以存在扩展，其中一个原因是，STL的设计目的就是为了便于扩展。但在本书中，我将把焦点放在如何使用STL上，而不是如何向其中添加新的部件。比如，你会发现，我将很少讲述如何编写自己的算法，对于如何编写新的容器和迭代器也没有给出任何建议。我相信，在考虑增强STL的能力之前，首先重要的是掌握STL已经提供了什么，而这正是本书的焦点所在。
:::

## 术语，术语，术语

::: note vector、string、deque 和 list 被称为标准序列容器。标准关联容器是 set、multiset、map 和 multimap。
:::

::: note
根据迭代器所支持的操作，可以把迭代器分为五类。简单来说，输入迭代器（input iterator）是只读迭代器，在每个被遍历到的位置上只能被读取一次。输出迭代器（output iterator）是只写迭代器，在每个被遍历到的位置上只能被写入一次。输入和输出迭代器的模型分别是建立在针对输入和输出流（例如文件）的读写操作的基础上的。所以不难理解，输入和输出迭代器最常见的表现形式是istream_iterator和ostream_iterator。

前向迭代器 （forward iterator）兼具输入和输出迭代器的能力，但是它可以对同一个位置重复进行读和写。前向迭代器不支持operator--，所以它只能向前移动。所有的标准STL容器都支持比前向迭代器功能更强大的迭代器，但是，你在第25条中可以看到，散列容器的一种设计会产生前向迭代器。单向链表容器（见第50条）也提供了前向迭代器。

双向迭代器 （bidirectional iterator）很像前向迭代器，只是它们向后移动和向前移动同样容易。标准关联容器都提供了双向迭代器。list也是如此。

随机访问迭代器 （random access iterator）有双向迭代器的所有功能，而且，它还提供了“迭代器算术”，即向前或向后跳跃一步的能力。vector、string和deque都提供了随机访问迭代器。指向数组内部的指针对于数组来说也是随机访问迭代器。
:::

::: note 所有重载了函数调用操作符（即operator()）的类都是一个函数子类（functor class）。从这些类创建的对象被称为函数对象（function object）或函数子（functor）。在STL中，大多数使用函数对象的地方同样也可以使用实际的函数，所以我经常使用“函数对象”（function object）这个术语既表示C++函数，也表示真正的函数对象。
:::

::: note 函数bind1st和bind2nd被称为绑定器（binder）。
:::

## 第1章 容器

### 第1条：慎重选择容器类型。

::: note
- 标准STL序列容器 ：vector、string、deque和list。

- 标准STL关联容器 ：set、multiset、map和multimap。

- 非标准序列容器slist和rope 。slist是一个单向链表，rope本质上是一“重型”string。（“rope”是重型“string”，明白了吗？）你可以在第50条中找到对这些非标准（但通常可以使用）的容器的一个简要介绍。

- 非标准关联容器hash_set、hash_multiset、hash_map和hash_multimap 。在第25条中，我分析了这些基于散列表的、标准关联容器的变体（它们通常是广泛可用的）。

- `vector<char>` 作为string的替代 。第13条讲述了在何种条件下这种替代是有意义的。

- vector作为标准关联容器的替代 。正如第23条中所阐明的，有时vector在运行时间和空间上都要优于标准关联容器。

- 几种标准的非STL容器 ，包括数组、bitset、valarray、stack、queue和priority_queue。因为它们不是STL容器，所以在本书中很少提及，仅在第16条中提到了一种“数组优于STL容器”的情形，以及在第18条中解释了为什么bitset比`vector<bool>`要好。值得记住的是，数组也可以被用于STL算法，因为指针可以被用作数组的迭代器。
:::

::: tip
对于容器，STL给了你多种选择。在STL以外，你还有更多的选择。在选择一个容器之前，请仔细考虑所有的选择。存在“默认的容器”吗？我可不这样认为。
:::

### 第2条：不要试图编写独立于容器类型的代码。

::: note 即便是最热心地倡导独立于容器类型的代码的人也很快会意识到，试图编写对序列容器和关联容器都适用的代码几乎是毫无意义的。很多成员函数仅当其容器为某一种类型时才存在，例如，只有序列容器才支持push_front或push_back，只有关联容器才支持count和lower_bound，等等。即使是insert和erase这样的基本操作，也会随容器类型的不同而表现出不同的原型和语义。
:::

::: note 面对现实吧：这么做不值得。不同的容器是不同的，它们有非常明显的优缺点。
:::

::: note 它们并不是被设计来交换使用的，你无法掩盖这一点。如果你试图这样做，你只是在碰运气，而这种运气却是碰不到的。
:::

### 第3条：确保容器中的对象副本正确而高效。

::: note 容器中保存了对象，但并不是你提供给容器的那些对象。而当从容器中取出一个对象时，你所取出的也并不是容器中所保存的那份。当向容器中加入对象时（通过如insert或push_back之类的操作），存入容器的是你所指定的对象的副本。当（通过如front或back之类的操作）从容器中取出一个对象时，你所得到的是容器中所保存的对象的副本。进去的是副本，出来的也是副本（copy in，copy out）。这就是STL的工作方式。
:::

::: note 当然，在存在继承关系的情况下，复制动作会导致剥离（slicing）。也就是说，如果你创建了一个存放基类对象的容器，却向其中插入派生类的对象，那么在派生类对象（通过基类的复制构造函数）被复制进容器时，它所特有的部分（即派生类中的信息）将会丢失。“剥离”问题意味着向基类对象的容器中插入派生类对象几乎总是错误的。如果你希望插入后的对象仍然表现得像派生类对象一样，例如调用派生类的虚函数等，那么这种期望是错误的。
:::

::: note 使复制动作高效、正确，并防止剥离问题发生的一个简单办法是使容器包含指针而不是对象。也就是说，使用Widget* 的容器，而不是Widget的容器。复制指针的速度非常快，并且总是会按你期望的方式进行（它复制构成指针的每一位），而且当它被复制时不会有任何剥离现象发生。不幸的是，指针的容器也有其自身的一些令人头疼的、与STL相关的问题。你可以参考第7条和第33条。如果你想避开这些使人头疼的问题，同时又想避免效率、正确性和剥离这些问题，你可能会发现智能指针（smart pointer）是一个诱人的选择。要想了解更多关于这种选择的知识，请参阅第7条。
:::

::: tip
与数组相比，STL容器要聪明得多。你让它创建多少对象，它就（通过复制）创建多少对象，不会多，也不会少。你让它创建时它才创建，只有当你让它使用默认构造函数时它才会使用。没错，STL容器是在创建副本；确实是这样的，你需要明白这一点。但是，跟数组相比，它们仍是迈出了一大步。这是一个不可忽略的事实
:::

### 第4条：调用empty而不是检查size()是否为0。

::: note 对任一容器c，下面的代码 `if(c.size()== 0)` 本质上与 `if (c.empty())` 是等价的。既然如此，你或许会疑惑为什么要偏向于某一种形式，尤其是考虑到empty通常被实现为内联函数（inline function），并且它所做的仅仅是返回size是否为0。
:::

::: note 你应该使用empty形式，理由很简单：empty对所有的标准容器都是常数时间操作，而对一些list实现，size耗费线性时间。
:::

::: tip
不管发生了什么，调用empty而不是检查size==0是否成立总是没错的。所以，如果你想知道容器中是否含有零个元素，请调用empty。
:::

### 第5条：区间成员函数优先于与之对应的单元素成员函数。

::: note 设计该小测验的第二个目的是为了揭示为什么区间成员函数（range member function）优先于与之对应的单元素成员函数。区间成员函数是指这样的一类成员函数，它们像STL算法一样，使用两个迭代器参数来确定该成员操作所执行的区间。如果不使用区间成员函数来解决本条款开篇时提出的问题，你就得写一个显式的循环。
:::

::: note 太多的STL程序员滥用了copy，所以我刚才给出的建议值得再重复一下：通过利用插入迭代器的方式来限定目标区间的copy调用，几乎都应该被替换为对区间成员函数的调用。
:::

::: note
现在回到assign的例子。我们已经给出了使用区间成员函数而不是其相应的单元素成员函数的原因：

- 通过使用区间成员函数，通常可以少写一些代码。

- 使用区间成员函数通常会得到意图清晰和更加直接的代码。
:::

::: note 效率分析
第一种影响是不必要的函数调用。把numValues个元素逐个插入到v中导致了对insert的numValues次调用。而使用区间形式的insert，则只做了一次函数调用，节省了numValues－1次。当然，使用内联（inlining）可能会避免这样的影响，但是，实际中不见得会使用内联。只有一点是肯定的：使用区间形式的insert，肯定不会有这样的影响。

内联无法避免第二种影响，即把v中已有的元素频繁地移动到插入后它们所处的位置。每次调用insert把新元素插入到v中时，插入点后的每个元素都要向后移动一个位置，以便为新元素腾出空间。所以，位置p的元素必须被移动到位置p＋l，等等。在我们的例子中，我们向v的前端插入numValues个元素，这意味着v中插入点之后的每个元素都要向后移动numValues个位置。每次调用insert时，每个元素需向后移动一个位置，所以每个元素将移动numValues次。如果插入前v中有n个元素，就会有n* numValues次移动。在这个例子中，v中存储的是int类型，每次移动最终可能会归为调用memmove，可是如果v中存储的是Widget这样的用户自定义类型，则每次移动会导致调用该类型的赋值操作符或复制构造函数。（大多数情况下会调用赋值操作符，但每次vector中的最后一个元素被移动时，将会调用该元素的复制构造函数。）所以在通常情况下，把numValues个元素逐个插入到含有n个元素的`vector<Widget>`的前端将会有n* numValues次函数调用的代价：(n－1)* numValues次调用Widget的赋值操作符和numValues次调用Widget的复制构造函数。即使这些调用是内联的，你仍然需要把v中的元素移动numValues次。

与此不同的是，C++标准要求区间insert函数把现有容器中的元素直接移动到它们最终的位置上，即只需付出每个元素移动一次的代价。总的代价包括n次移动、numValues次调用该容器中元素类型的复制构造函数，以及调用该类型的赋值操作符。同每次插入一个元素的策略相比较，区间insert减少了n* (numValues－1)次移动。细算下来，这意味着如果numValues是100，那么区间形式的insert比重复调用单元素形式的insert减少了99％的移动。

在讲述单元素形式的成员函数和与其对应的区间成员函数相比较所存在的第三个效率问题之前，我需要做一个小小的更正。我在前面的段落中所写的是对的，的确是对的，但并不总是对的。区间insert函数仅当能确定两个迭代器之间的距离而不会失去它们的位置时，才可以一次就把元素移动到其最终位置上。这几乎总是可能的，因为所有的前向迭代器都提供了这样的功能，而前向迭代器几乎无处不在。标准容器的所有迭代器都提供了前向迭代器的功能。非标准散列容器的迭代器也是如此（见第25条）。指针作为数组的迭代器也提供了这一功能。实际上，不提供这一功能的标准迭代器仅有输入和输出迭代器。所以，我所说的是正确的，除非传入区间形式insert的是输入迭代器（如istream_iterator，见第6条）。仅在这样的情况下，区间insert也必须把元素一步步移动到其最终位置上，因而它的优势就丧失了。（对于输出迭代器不会产生这个问题，因为输出迭代器不能用来标明一个区间。）

不明智地使用重复的单元素插入操作而不是一次区间插入操作，这样所带来的最后一个性能问题跟内存分配有关，尽管它同时还伴有讨厌的复制问题。在第14条将会指出，如果试图把一个元素插入到vector中，而它的内存已满，那么vector将分配具有更大容量（capacity）的新内存，把它的元素从旧内存复制到新内存中，销毁旧内存中的元素，并释放旧内存。然后它把要插入的元素加入进来。第14条还解释了多数vector实现每次在内存耗尽时，会把容量加倍，因此，插入numValues个新元素最多可导致`log<sub>2</sub>numValues`次新的内存分配。第14条指出，表现出这种行为的vector实现是存在的，因此，把1000个元素逐个插入可能会导致10次新的内存分配（包括低效的元素复制）。与之对应（而且，到现在为止也可以预见），使用区间插入的方法，在开始插入前可以知道自己需要多少新内存（假定给它的是前向迭代器），所以不必多次重新分配vector的内存。可以想见，这一节省是很可观的。
:::


::: tip
现在你明白了，优先选择区间成员函数而不是其对应的单元素成员函数有三条充分的理由：区间成员函数写起来更容易，更能清楚地表达你的意图，而且它们表现出了更高的效率。这是很难被打败的三驾马车。
:::