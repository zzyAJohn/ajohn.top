---
title: 4.1 DFS
tags:
    - Leetcode
    - Python
createTime: 2024/12/17 20:58:12
permalink: /leetcode/z19ksk85/
---

::: tip 提示
适用于需要计算连通块个数、大小的题目。

部分题目也可以用 BFS 或并查集解决。

阿囧：挺像扫雷的（
:::

1. [200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/description/)

    ```py
    class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        m, n = len(grid), len(grid[0])
        def dfs(i, j):
            if i < 0 or j < 0 or i >= m or j >= n or grid[i][j] != '1': # 地图外面或者非陆地就返回
                return
            grid[i][j] = '2' # 是陆地，插旗
            dfs(i - 1, j) # 其他四个方向走走
            dfs(i + 1, j)
            dfs(i, j - 1)
            dfs(i, j + 1)

        res = 0
        for i, row in enumerate(grid):
            for j, c in enumerate(row):
                if c == '1': # 发现岛屿
                    res += 1
                    dfs(i, j) # 占领此岛，插满旗子 '2'
        return res
    ```

    时间复杂度：O(mn)，其中 m 和 n 分别为 grid 的行数和列数。

    空间复杂度：O(mn)。最坏情况下，递归需要 O(mn) 的栈空间。

2. [695. 岛屿的最大面积](https://leetcode.cn/problems/max-area-of-island/)

    ```py
    class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        def dfs(i, j):
            if i < 0 or j < 0 or i >= m or j >= n or grid[i][j] != 1:
                return 0
            grid[i][j] = 2
            return 1 + dfs(i - 1, j) + dfs(i + 1, j) + dfs(i, j - 1) + dfs(i, j + 1)

        res = 0
        for i, row in enumerate(grid):
            for j, c in enumerate(row):
                if grid[i][j] == 1:
                    res = max(res, dfs(i, j))
        return res
    ```

    时间复杂度：O(mn)，其中 m 和 n 分别为 grid 的行数和列数。

    空间复杂度：O(mn)。最坏情况下，递归需要 O(mn) 的栈空间。

3. [面试题 16.19. 水域大小](https://leetcode.cn/problems/pond-sizes-lcci/description/)

    **注意此题是 8 方向，这题才是扫雷，but who care ? 一力破万法**

    ```py
    class Solution:
    def pondSizes(self, land: List[List[int]]) -> List[int]:
        m, n = len(land), len(land[0])
        def dfs(i, j):
            if i < 0 or j < 0 or i >= m or j >= n or land[i][j] != 0:
                return 0
            land[i][j] = 1
            return 1 + dfs(i - 1, j - 1) + dfs(i - 1, j) + dfs(i - 1, j + 1) + dfs(i, j - 1) + dfs(i, j + 1) + dfs(i + 1, j - 1) + dfs(i + 1, j) + dfs(i + 1, j + 1)

        res = []
        for i, row in enumerate(land):
            for j, c in enumerate(row):
                if land[i][j] == 0:
                    res.append(dfs(i, j))
        res.sort()
        return res
    ```

    时间复杂度：O(mn)，其中 m 和 n 分别为 land 的行数和列数。

    空间复杂度：O(mn)。最坏情况下，递归需要 O(mn) 的栈空间。

4. [LCS 03. 主题空间](https://leetcode.cn/problems/YesdPw/description/)

    ```py
    class Solution:
    def largestArea(self, grid: List[str]) -> int:
        grid = [list(i) for i in grid]
        m, n = len(grid), len(grid[0])
        def dfs(i,j):
            nonlocal now
            if i < 0 or j < 0 or i >= m or j >= n or grid[i][j] == '0': # 外面和里面0元素
                return float('-inf')
            if grid[i][j]== now: # 现在只剩下里面非0元素，找到是同一主题的
                grid[i][j] = "6"
                return dfs(i+1,j) + dfs(i-1,j)+ dfs(i,j-1)+dfs(i,j+1) + 1
            else:
                return 0
            
        res = 0
        for i, row in enumerate(grid):
            for j, c in enumerate(row):
                now = grid[i][j]
                if c != '0' and c != '6':
                    res = max(res, dfs(i, j))
        return res
    ```

    时间复杂度：O(mn)，其中 m 和 n 分别为 grid 的行数和列数。

    空间复杂度：O(mn)。最坏情况下，递归需要 O(mn) 的栈空间。

5. [463. 岛屿的周长](https://leetcode.cn/problems/island-perimeter/description/)

    ```py
    ```

    时间复杂度：O(mn)，其中 m 和 n 分别为 grid 的行数和列数。

    空间复杂度：O(mn)。最坏情况下，递归需要 O(mn) 的栈空间。

6. [2658. 网格图中鱼的最大数目](https://leetcode.cn/problems/maximum-number-of-fish-in-a-grid/description/)

    ```py
    class Solution:
    def findMaxFish(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        def dfs(i, j):
            if i < 0 or j < 0 or i >=m or j >= n or grid[i][j] <= 0:
                return 0
            fish = grid[i][j]
            grid[i][j] = -1
            return fish + dfs(i - 1, j) + dfs(i + 1, j) + dfs(i, j - 1) + dfs(i, j + 1)

        res = 0
        for i, row in enumerate(grid):
            for j, c in enumerate(row):
                if c > 0:
                    res = max(res, dfs(i, j))
        return res
    ```

    时间复杂度：O(mn)，其中 m 和 n 分别为 grid 的行数和列数。

    空间复杂度：O(mn)。最坏情况下，递归需要 O(mn) 的栈空间。


7. [2658. 网格图中鱼的最大数目](https://leetcode.cn/problems/maximum-number-of-fish-in-a-grid/description/)

    ```py
    class Solution:
    def findMaxFish(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        def dfs(i, j):
            if i < 0 or j < 0 or i >=m or j >= n or grid[i][j] <= 0:
                return 0
            fish = grid[i][j]
            grid[i][j] = -1
            return fish + dfs(i - 1, j) + dfs(i + 1, j) + dfs(i, j - 1) + dfs(i, j + 1)

        res = 0
        for i, row in enumerate(grid):
            for j, c in enumerate(row):
                if c > 0:
                    res = max(res, dfs(i, j))
        return res
    ```

    时间复杂度：O(mn)，其中 m 和 n 分别为 grid 的行数和列数。

    空间复杂度：O(mn)。最坏情况下，递归需要 O(mn) 的栈空间。


8. [1034. 边界着色](https://leetcode.cn/problems/coloring-a-border/description/)

    ```py
    class Solution:
    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:
        visited = set()
        border = []
        target = grid[row][col]
        m, n = len(grid), len(grid[0])
        def dfs(i, j):
            if i < 0 or j < 0 or i >= m or j >= n or grid[i][j] != target: # 不是连通的，返回False
                return False
            
            if (i, j) in visited:
                return True
            
            visited.add((i, j))

            is_border = False # 默认不是边界

            for (x, y) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]: # 遍历上下左右
                if x < 0 or y < 0 or x >= m or y >= n or grid[x][y] != target:
                    is_border = True # 如果旁边越界或者是其他颜色了，说明是边界
                else:
                    if dfs(x, y): # 如果是连通的，遍历他
                        continue
            if is_border:
                border.append((i, j))

            return True # 是连通的

        dfs(row, col)
        for i, j in border:
            grid[i][j] = color
        return grid
    ```

    时间复杂度：O(mn)，其中 m 和 n 分别为 grid 的行数和列数。

    空间复杂度：O(mn)。最坏情况下，递归需要 O(mn) 的栈空间。

