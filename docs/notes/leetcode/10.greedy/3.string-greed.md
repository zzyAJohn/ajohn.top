---
title: 10.3 字符串贪心
createTime: 2025/05/26 13:13:32
permalink: /leetcode/jweiknx0/
---

### 10.3.1 字典序最小/最大

字典序的定义如下：

- 对于两个字符串 a 和 b，从左到右依次比较 a[i] 和 b[i] 的字符 ASCII 值的大小。
- a[i]!=b[i] 时，如果 a[i]<b[i]，那么 a 的字典序更小，否则 b 的字典序更小。
- 如果没有出现 a[i]!=b[i]，则短的字符串字典序更小。
- 如果两个字符串的长度和内容均相同，那么两个字符串的字典序一样。

字典序的定义也可以推广到数组上，按照上述方法比较两个数组的字典序。

1. [1323. 6 和 9 组成的最大数字](https://leetcode.cn/problems/maximum-69-number/description/)

    <Badge type="info" text="给你一个仅由数字 6 和 9 组成的正整数 num。你最多只能翻转一位数字，将 6 变成 9，或者把 9 变成 6 。请返回你可以得到的最大数字。" />

    ::: tabs
    @tab 示例 1：
    
    输入：num = 9669  
    输出：9969  
    解释：  
    改变第一位数字可以得到 6669 。  
    改变第二位数字可以得到 9969 。  
    改变第三位数字可以得到 9699 。  
    改变第四位数字可以得到 9666 。  
    其中最大的数字是 9969 。

    @tab 示例 2：

    输入：num = 9996  
    输出：9999  
    解释：将最后一位从 6 变到 9，其结果 9999 是最大的数。

    @tab 示例 3：

    输入：num = 9999  
    输出：9999  
    解释：无需改变就已经是最大的数字了。
    :::

    ::: tip 
    思路：转换成字符串调用 replace 函数即可。
    :::

    ```py
    class Solution:
    def maximum69Number (self, num: int) -> int:
        return int(str(num).replace('6', '9', 1))
    ```
    
    时间复杂度：$O(n)$，其中 n 为 num 的长度。

    空间复杂度：$O(n)$。

2. [3216. 交换后字典序最小的字符串](https://leetcode.cn/problems/lexicographically-smallest-string-after-a-swap/description/)

    <Badge type="info" text="给你一个仅由数字组成的字符串 s，在最多交换一次 相邻 且具有相同 奇偶性 的数字后，返回可以得到的字典序最小的字符串。如果两个数字都是奇数或都是偶数，则它们具有相同的奇偶性。例如，5 和 9、2 和 4 奇偶性相同，而 6 和 9 奇偶性不同。" />

    ::: tabs
    @tab 示例 1：
    
    输入： s = "45320"  
    输出： "43520"  
    解释：  
    s[1] == '5' 和 s[2] == '3' 都具有相同的奇偶性，交换它们可以得到字典序最小的字符串。

    @tab 示例 2：

    输入： s = "001"  
    输出： "001"  
    解释：  
    无需进行交换，因为 s 已经是字典序最小的。
    :::

    ::: tip 
    思路：从第二个数字开始遍历，如果比上一个数字小，且这两个数字奇偶性相同（相加为偶数），则交换位置，最后返回交换后的字符串。
    :::

    ```py
    class Solution:
    def getSmallestString(self, s: str) -> str:
        l = list(s)
        for i in range(1, len(l)):
            if l[i - 1] > l[i] and (int(l[i - 1]) + int(l[i])) % 2 == 0:
                l[i - 1], l[i] = l[i], l[i - 1]
                break
        return ''.join(l)
    ```
    
    时间复杂度：$O(n)$，其中 n 为 s 的长度。

    空间复杂度：$O(n)$。

3. [2697. 字典序最小回文串](https://leetcode.cn/problems/lexicographically-smallest-palindrome/description/)

    <Badge type="info" text="给你一个由 小写英文字母 组成的字符串 s ，你可以对其执行一些操作。在一步操作中，你可以用其他小写英文字母 替换  s 中的一个字符。请你执行 尽可能少的操作 ，使 s 变成一个 回文串 。如果执行 最少 操作次数的方案不止一种，则只需选取 字典序最小 的方案。对于两个长度相同的字符串 a 和 b ，在 a 和 b 出现不同的第一个位置，如果该位置上 a 中对应字母比 b 中对应字母在字母表中出现顺序更早，则认为 a 的字典序比 b 的字典序要小。返回最终的回文字符串。" />

    ::: tabs
    @tab 示例 1：
    
    输入：s = "egcfe"  
    输出："efcfe"  
    解释：将 "egcfe" 变成回文字符串的最小操作次数为 1 ，修改 1 次得到的字典序最小回文字符串是 "efcfe"，只需将 'g' 改为 'f' 。

    @tab 示例 2：

    输入：s = "abcd"  
    输出："abba"  
    解释：将 "abcd" 变成回文字符串的最小操作次数为 2 ，修改 2 次得到的字典序最小回文字符串是 "abba" 。

    @tab 示例 3：

    输入：s = "seven"  
    输出："neven"  
    解释：将 "seven" 变成回文字符串的最小操作次数为 1 ，修改 1 次得到的字典序最小回文字符串是 "neven" 。
    :::

    ::: tip 
    思路：使用两个指针，分别从前后开始往中间遍历，如果不相同则将字典序大的替换。
    :::

    ```py
    class Solution:
    def makeSmallestPalindrome(self, s: str) -> str:
        l = list(s)
        left = 0
        right = len(l) - 1
        while left < right:
            if l[left] > l[right]:
                l[left] = l[right] 
            else:
                l[right] = l[left]
            left += 1
            right -= 1
        return ''.join(l)
    ```
    
    时间复杂度：$O(n)$，其中 n 为 s 的长度。

    空间复杂度：$O(n)$。

4. [1881. 插入后的最大值](https://leetcode.cn/problems/maximum-value-after-insertion/description/)

    <Badge type="info" text="给你一个非常大的整数 n 和一个整数数字 x ，大整数 n 用一个字符串表示。n 中每一位数字和数字 x 都处于闭区间 [1, 9] 中，且 n 可能表示一个 负数 。你打算通过在 n 的十进制表示的任意位置插入 x 来 最大化 n 的 数值 ​​​​​​。但 不能 在负号的左边插入 x 。例如，如果 n = 73 且 x = 6 ，那么最佳方案是将 6 插入 7 和 3 之间，使 n = 763 。如果 n = -55 且 x = 2 ，那么最佳方案是将 2 插在第一个 5 之前，使 n = -255 。返回插入操作后，用字符串表示的 n 的最大值。" />

    ::: tabs
    @tab 示例 1：
    
    输入：n = "99", x = 9  
    输出："999"  
    解释：不管在哪里插入 9 ，结果都是相同的。

    @tab 示例 2：

    输入：n = "-13", x = 2  
    输出："-123"  
    解释：向 n 中插入 x 可以得到 -213、-123 或者 -132 ，三者中最大的是 -123 。
    :::

    ::: tip 
    思路：对于正数，要求找到第一个严格小于x的数，插在这个数前面；对于负数，找到第一个严格大于x的数，插在这个数前面；如果没找到，插在最后。
    :::

    ```py
    class Solution:
    def maxValue(self, n: str, x: int) -> str:
        l = list(n)
        if l[0] == '-':
            for i in range(1, len(l)):
                if int(l[i]) > x:
                    l.insert(i, str(x))
                    break
                if i == len(l) - 1:
                    l.append(str(x))
        else:
            for i in range(len(l)):
                if int(l[i]) < x:
                    l.insert(i, str(x))
                    break
                if i == len(l) - 1:
                    l.append(str(x))
        return ''.join(l)
    ```
    
    时间复杂度：$O(n)$，其中 n 为 s 的长度。

    空间复杂度：$O(n)$。

5. [2734. 执行子串操作后的字典序最小字符串](https://leetcode.cn/problems/lexicographically-smallest-string-after-substring-operation/description/)

    <Badge type="info" text="给你一个仅由小写英文字母组成的字符串 s 。在一步操作中，你可以完成以下行为：选择 s 的任一非空子字符串，可能是整个字符串，接着将字符串中的每一个字符替换为英文字母表中的前一个字符。例如，'b' 用 'a' 替换，'a' 用 'z' 替换。返回执行上述操作 恰好一次 后可以获得的 字典序最小 的字符串。子字符串 是字符串中的一个连续字符序列。现有长度相同的两个字符串 x 和 字符串 y ，在满足 x[i] != y[i] 的第一个位置 i 上，如果  x[i] 在字母表中先于 y[i] 出现，则认为字符串 x 比字符串 y 字典序更小 。" />

    ::: tabs
    @tab 示例 1：
    
    输入：s = "cbabc"  
    输出："baabc"  
    解释：我们选择从下标 0 开始、到下标 1 结束的子字符串执行操作。   
    可以证明最终得到的字符串是字典序最小的。

    @tab 示例 2：

    输入：s = "acbbc"  
    输出："abaab"  
    解释：我们选择从下标 1 开始、到下标 4 结束的子字符串执行操作。  
    可以证明最终得到的字符串是字典序最小的。

    @tab 示例 3：

    输入：s = "leetcode"  
    输出："kddsbncd"  
    解释：我们选择整个字符串执行操作。  
    可以证明最终得到的字符串是字典序最小的。
    :::

    ::: tip 
    思路：从左起第一个不为a的字符开始替换，直到遇到a，这题比较坑的是aa也需要换成az，我使用了一个change变量记录是否改变，如果没有改变，那么把最后一个a改成z。
    :::

    ```py
    class Solution:
    def smallestString(self, s: str) -> str:
        l = list(s)
        change = False
        for i in range(len(l)):
            if l[i] != 'a':
                l[i] = chr(ord(l[i]) - 1)
                change = True
            else:
                if i == len(l) - 1 and not change:
                    l[i] = 'z'
                if i != 0 and change:
                    break
        return ''.join(l)
    ```
    
    时间复杂度：$O(n)$，其中 n 为 s 的长度。

    空间复杂度：$O(n)$。