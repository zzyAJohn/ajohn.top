---
title: 10.1 贪心策略
createTime: 2025/04/16 10:50:42
permalink: /leetcode/9m2l6ggc/
---


>有时候，很难一眼看出一道题是贪心还是 DP。


前言


为方便大家练习，我把比较套路的贪心题目放在前面，更灵活的思维题和构造题放在后面。每个小节的题目均按照从易到难的顺序排列。

如果做题时没有思路，推荐看看本文第五章的「思考清单」。

有两种**基本贪心策略**：

1. 从**最小/最大**开始贪心，优先考虑最小/最大的数，从小到大/从大到小贪心。在此基础上，衍生出了**反悔贪心**。

2. 从**最左/最右**开始贪心，思考第一个数/最后一个数的贪心策略，把 n 个数的原问题转换成 n−1 个数（或更少）的子问题。


## 10.1.1 从最小/最大开始贪心
优先考虑最小/最大的数，从小到大/从大到小贪心。

如果答案与数组元素顺序无关，一般需要**排序**。排序后，可以遍历计算。

1. [3074. 重新分装苹果](https://leetcode.cn/problems/apple-redistribution-into-boxes/description/)

    <Badge type="info" text="给你一个长度为 n 的数组 apple 和另一个长度为 m 的数组 capacity 。一共有 n 个包裹，其中第 i 个包裹中装着 apple[i] 个苹果。同时，还有 m 个箱子，第 i 个箱子的容量为 capacity[i] 个苹果。请你选择一些箱子来将这 n 个包裹中的苹果重新分装到箱子中，返回你需要选择的箱子的 最小 数量。注意，同一个包裹中的苹果可以分装到不同的箱子中。" />

    ::: tabs
    @tab 示例 1：
    
    输入：apple = [1,3,2], capacity = [4,3,1,5,2]  
    输出：2  
    解释：使用容量为 4 和 5 的箱子。  
    总容量大于或等于苹果的总数，所以可以完成重新分装。

    @tab 示例 2：

    输入：apple = [5,5,5], capacity = [2,4,2,7]  
    输出：4  
    解释：需要使用所有箱子。
    :::

    ::: tip 
    思路：**从最大开始贪心。** 要求最少的箱子使用量，并且苹果是可以分装的，那么只需要求出苹果的总重，然后依次从大到小选择箱子，直到满足苹果总重即可。
    :::

    ```py
    class Solution:
    def minimumBoxes(self, apple: List[int], capacity: List[int]) -> int:
        total = sum(apple) # O(n)
        capacity.sort(reverse=True) # O(mlogm)
        cur_capacity = 0
        for i, c in enumerate(capacity): # O(m)
            cur_capacity += c
            if cur_capacity >= total:
                return i + 1
    ```
    
    时间复杂度：$O(n+mlogm)$，其中 n 为 apple 的长度，m 为 capacity 的长度。

    空间复杂度：$O(1)$，忽略排序的栈开销。

2. [2279. 装满石头的背包的最大数量](https://leetcode.cn/problems/maximum-bags-with-full-capacity-of-rocks/description/)

    <Badge type="info" text="现有编号从 0 到 n - 1 的 n 个背包。给你两个下标从 0 开始的整数数组 capacity 和 rocks 。第 i 个背包最大可以装 capacity[i] 块石头，当前已经装了 rocks[i] 块石头。另给你一个整 additionalRocks ，表示你可以放置的额外石头数量，石头可以往 任意 背包中放置。请你将额外的石头放入一些背包中，并返回放置后装满石头的背包的 最大 数量。" />

    ::: tabs
    @tab 示例 1：
    
    输入：capacity = [2,3,4,5], rocks = [1,2,4,4], additionalRocks = 2  
    输出：3  
    解释：  
    1 块石头放入背包 0 ，1 块石头放入背包 1 。  
    每个背包中的石头总数是 [2,3,4,4] 。  
    背包 0 、背包 1 和 背包 2 都装满石头。  
    总计 3 个背包装满石头，所以返回 3 。  
    可以证明不存在超过 3 个背包装满石头的情况。  
    注意，可能存在其他放置石头的方案同样能够得到 3 这个结果。 

    @tab 示例 2：
    
    输入：capacity = [10,2,2], rocks = [2,2,0], additionalRocks = 100  
    输出：3  
    解释：  
    8 块石头放入背包 0 ，2 块石头放入背包 2 。  
    每个背包中的石头总数是 [10,2,2] 。  
    背包 0 、背包 1 和背包 2 都装满石头。  
    总计 3 个背包装满石头，所以返回 3 。  
    可以证明不存在超过 3 个背包装满石头的情况。  
    注意，不必用完所有的额外石头。
    :::

    ::: tip 
    思路：**从最小开始贪心。** 要求最多能装满多少背包，可以先求出背包的空余容量，然后从小到大排序，把额外石头依次装满背包，直到石头用完，这时装满的背包数量就是所求。
    :::

    ```py
    class Solution:
    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:
        free = [c - r for c, r in zip(capacity, rocks)] # O(n)
        free.sort() # O(nlogn)
        for i, f in enumerate(free): # O(n)
            additionalRocks -= f
            if additionalRocks == 0:
                return i + 1
            elif additionalRocks < 0:
                return i
        return len(capacity)
    ```
    
    时间复杂度：$O(nlogn)$，其中 n 为 capacity 的长度。

    空间复杂度：$O(n)$，忽略排序的栈开销。


3. [1833. 雪糕的最大数量](https://leetcode.cn/problems/maximum-ice-cream-bars/description/)

    <Badge type="info" text="夏日炎炎，小男孩 Tony 想买一些雪糕消消暑。商店中新到 n 支雪糕，用长度为 n 的数组 costs 表示雪糕的定价，其中 costs[i] 表示第 i 支雪糕的现金价格。Tony 一共有 coins 现金可以用于消费，他想要买尽可能多的雪糕。注意：Tony 可以按任意顺序购买雪糕。给你价格数组 costs 和现金量 coins ，请你计算并返回 Tony 用 coins 现金能够买到的雪糕的 最大数量 。你必须使用计数排序解决此问题。" />

    ::: tabs
    @tab 示例 1：
    
    输入：costs = [1,3,2,4,1], coins = 7  
    输出：4  
    解释：Tony 可以买下标为 0、1、2、4 的雪糕，总价为 1 + 3 + 2 + 1 = 7 

    @tab 示例 2：
    
    输入：costs = [10,6,8,7,7,8], coins = 5  
    输出：0  
    解释：Tony 没有足够的钱买任何一支雪糕。

    @tab 示例 3：
    
    输入：costs = [1,6,3,1,2,5], coins = 20  
    输出：6  
    解释：Tony 可以买下所有的雪糕，总价为 1 + 6 + 3 + 1 + 2 + 5 = 18 。
    :::

    ::: tip 
    思路：**从最小开始贪心。** 要求买更多数量的雪糕，因此我们要尽可能买便宜的（小布丁而不是巧乐兹），把雪糕价格从小到大排序，然后购买即可。
    :::

    ```py
    class Solution:
    def maxIceCream(self, costs: List[int], coins: int) -> int:
        costs.sort() # O(nlogn)
        for i, c in enumerate(costs): # O(n)
            coins -= c
            if coins == 0:
                return i + 1
            elif coins < 0:
                return i
        return len(costs)
    ```
    
    时间复杂度：$O(nlogn)$，其中 n 为 costs 的长度。

    空间复杂度：$O(1)$，忽略排序的栈开销。

4. [1005. K 次取反后最大化的数组和](https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/description/)

    <Badge type="info" text="给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：选择某个下标 i 并将 nums[i] 替换为 -nums[i] 重复这个过程恰好 k 次。可以多次选择同一个下标 i 。以这种方式修改数组后，返回数组 可能的最大和。" />

    ::: tabs
    @tab 示例 1：
    
    输入：nums = [4,2,3], k = 1  
    输出：5  
    解释：选择下标 1 ，nums 变为 [4,-2,3] 。

    @tab 示例 2：
    
    输入：nums = [3,-1,0,2], k = 3  
    输出：6  
    解释：选择下标 (1, 2, 2) ，nums 变为 [3,1,0,2] 。

    @tab 示例 3：
    
    输入：nums = [2,-3,-1,5,-4], k = 2  
    输出：13  
    解释：选择下标 (1, 4) ，nums 变为 [2,3,-1,5,4] 。
    :::

    ::: tip 
    思路：**从最小开始贪心。** 要求数组的和最大，同时数组有正有负，那么我们可以先把数组排序，然后把前面的负数翻转，当负数全部翻转完毕，此时如果还有k，因为可以多次选择同一个下标，所以可以按照奇偶来分类，如果k是奇数，那么翻转最小的正数（提前存储），如果是偶数，不需要翻转。还有一种情况，那就是 nums 中全部是负数，且 k > len(nums) ，此时因为超过for循环，因此在循环外需要额外判断一次。（感觉这里可以优化一下）
    :::

    ```py
    class Solution:
    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:
        nums.sort() # O(nlogn)
        min_value = float('inf')
        for i, num in enumerate(nums): # O(n)
            if num < 0:
                min_value = min(-num, min_value)
                nums[i] = -num
                k -= 1
            elif num >= 0:
                min_value = min(num, min_value)
                if k % 2 == 0:
                    return sum(nums)
                else:
                    return sum(nums) - 2 * min_value
            if k == 0:
                return sum(nums)
        return sum(nums) - 2 * min_value if k and k % 2 else sum(nums)
    ```
    
    时间复杂度：$O(nlogn)$，其中 n 为 nums 的长度。

    空间复杂度：$O(1)$，忽略排序的栈开销。

    ::: tip
    `sum(nums)` 虽然是 $O(n)$，但它只在满足条件时被执行一次，而且之后整个函数就 `return`，循环立刻结束。所以，最多只会执行一次 $O(n)$ 的 `sum(nums)`。所以，循环内部总体时间复杂度是：$O(n) + O(n) = O(n)$，而不是 $O(n^2)$。
    :::

5. [1481. 不同整数的最少数目](https://leetcode.cn/problems/least-number-of-unique-integers-after-k-removals/description/)

    <Badge type="info" text="给你一个整数数组 arr 和一个整数 k 。现需要从数组中恰好移除 k 个元素，请找出移除后数组中不同整数的最少数目。" />

    ::: tabs
    @tab 示例 1：
    
    输入：arr = [5,5,4], k = 1  
    输出：1  
    解释：移除 1 个 4 ，数组中只剩下 5 一种整数

    @tab 示例 2：
    
    输入：arr = [4,3,1,1,3,3,2], k = 3  
    输出：2  
    解释：先移除 4、2 ，然后再移除两个 1 中的任意 1 个或者三个 3 中的任意 1 个，最后剩下 1 和 3 两种整数。
    :::

    ::: tip 
    思路：**从最小开始贪心。** 要求数组中的元素种类最少，我们需要先移除数量较少的数字类别，可以初始化一个计数器，然后把计数器按照 value 的值从小到大排序，先移走小的类别，最后如果数组全部被移走，返回0。
    :::

    ```py
    class Solution:
    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:
        from collections import Counter

        cnt_arr = sorted(Counter(arr).values()) # O(n) + O(mlogm)
        for i, num in enumerate(cnt_arr): # O(m)
            k -= num
            if k >= 0:
                continue
            if k < 0:
                return len(cnt_arr) - i
        return 0
    ```
    
    时间复杂度：$O(nlogn)$，其中 n 为 nums 的长度。

    空间复杂度：$O(n)$，忽略排序的栈开销。

    ::: tip
    m 为 nums 的种类数，因为 m 不会超过 n，故 $O(n) + O(mlogm)$可简化为$O(nlogn)$。
    :::

6. [1403. 非递增顺序的最小子序列](https://leetcode.cn/problems/minimum-subsequence-in-non-increasing-order/description/)

    <Badge type="info" text="给你一个数组 nums，请你从中抽取一个子序列，满足该子序列的元素之和 严格 大于未包含在该子序列中的各元素之和。如果存在多个解决方案，只需返回 长度最小 的子序列。如果仍然有多个解决方案，则返回 元素之和最大 的子序列。与子数组不同的地方在于，「数组的子序列」不强调元素在原数组中的连续性，也就是说，它可以通过从数组中分离一些（也可能不分离）元素得到。注意，题目数据保证满足所有约束条件的解决方案是 唯一 的。同时，返回的答案应当按 非递增顺序 排列。" />

    ::: tabs
    @tab 示例 1：
    
    输入：nums = [4,3,10,9,8]  
    输出：[10,9]   
    解释：子序列 [10,9] 和 [10,8] 是最小的、满足元素之和大于其他各元素之和的子序列。但是 [10,9] 的元素之和最大。

    @tab 示例 2：
    
    输入：nums = [4,4,7,6,7]  
    输出：[7,7,6]   
    解释：子序列 [7,7] 的和为 14 ，不严格大于剩下的其他元素之和（14 = 4 + 4 + 6）。因此，[7,6,7] 是满足题意的最小子序列。注意，元素按非递增顺序返回。
    :::

    ::: tip 
    思路：**从最大开始贪心。** 要求数组的子序列的数量尽可能少，子序列的和尽可能大，因此可以考虑从最大值开始选取子序列，这可以通过从大到小排序实现。为了方便书写代码，我们可以使用一个数学技巧：只要选取的子序列之和大于总数组之和的一半即可满足题目要求。
    :::

    ```py
    class Solution:
    def minSubsequence(self, nums: List[int]) -> List[int]:
   
        sum_nums = sum(nums) # O(n)
        nums.sort(reverse=True) # O(nlogn)
        cur = 0
        for i, num in enumerate(nums): # O(n)
            cur += num
            if cur > sum_nums / 2:
                return nums[:i + 1]
    ```
    
    时间复杂度：$O(nlogn)$，其中 n 为 nums 的长度。

    空间复杂度：$O(n)$，忽略排序的栈开销。

    ::: tip
    nums[:i + 1]创建了一个新列表，包含前 k 个元素（最坏 $O(n)$）
    :::



