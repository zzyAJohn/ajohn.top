---
title: 10.1 贪心策略
createTime: 2025/04/16 10:50:42
permalink: /leetcode/9m2l6ggc/
---


>有时候，很难一眼看出一道题是贪心还是 DP。


前言


为方便大家练习，我把比较套路的贪心题目放在前面，更灵活的思维题和构造题放在后面。每个小节的题目均按照从易到难的顺序排列。

如果做题时没有思路，推荐看看本文第五章的「思考清单」。

有两种**基本贪心策略**：

1. 从**最小/最大**开始贪心，优先考虑最小/最大的数，从小到大/从大到小贪心。在此基础上，衍生出了**反悔贪心**。

2. 从**最左/最右**开始贪心，思考第一个数/最后一个数的贪心策略，把 n 个数的原问题转换成 n−1 个数（或更少）的子问题。


## 10.1.1 从最小/最大开始贪心
优先考虑最小/最大的数，从小到大/从大到小贪心。

如果答案与数组元素顺序无关，一般需要**排序**。排序后，可以遍历计算。

1. [3074. 重新分装苹果](https://leetcode.cn/problems/apple-redistribution-into-boxes/description/)

    <Badge type="info" text="给你一个长度为 n 的数组 apple 和另一个长度为 m 的数组 capacity 。一共有 n 个包裹，其中第 i 个包裹中装着 apple[i] 个苹果。同时，还有 m 个箱子，第 i 个箱子的容量为 capacity[i] 个苹果。请你选择一些箱子来将这 n 个包裹中的苹果重新分装到箱子中，返回你需要选择的箱子的 最小 数量。注意，同一个包裹中的苹果可以分装到不同的箱子中。" />

    ::: tabs
    @tab 示例 1：
    
    输入：apple = [1,3,2], capacity = [4,3,1,5,2]  
    输出：2  
    解释：使用容量为 4 和 5 的箱子。  
    总容量大于或等于苹果的总数，所以可以完成重新分装。

    @tab 示例 2：

    输入：apple = [5,5,5], capacity = [2,4,2,7]  
    输出：4  
    解释：需要使用所有箱子。
    :::

    ::: tip 
    思路：**从最大开始贪心。** 要求最少的箱子使用量，并且苹果是可以分装的，那么只需要求出苹果的总重，然后依次从大到小选择箱子，直到满足苹果总重即可。
    :::

    ```py
    class Solution:
    def minimumBoxes(self, apple: List[int], capacity: List[int]) -> int:
        total = sum(apple) # O(n)
        capacity.sort(reverse=True) # O(mlogm)
        cur_capacity = 0
        for i, c in enumerate(capacity): # O(m)
            cur_capacity += c
            if cur_capacity >= total:
                return i + 1
    ```
    
    时间复杂度：$O(n+mlogm)$，其中 n 为 apple 的长度，m 为 capacity 的长度。

    空间复杂度：$O(1)$。忽略排序的栈开销。

2. [2279. 装满石头的背包的最大数量](https://leetcode.cn/problems/maximum-bags-with-full-capacity-of-rocks/description/)

    <Badge type="info" text="现有编号从 0 到 n - 1 的 n 个背包。给你两个下标从 0 开始的整数数组 capacity 和 rocks 。第 i 个背包最大可以装 capacity[i] 块石头，当前已经装了 rocks[i] 块石头。另给你一个整 additionalRocks ，表示你可以放置的额外石头数量，石头可以往 任意 背包中放置。请你将额外的石头放入一些背包中，并返回放置后装满石头的背包的 最大 数量。" />

    ::: tabs
    @tab 示例 1：
    
    输入：capacity = [2,3,4,5], rocks = [1,2,4,4], additionalRocks = 2  
    输出：3  
    解释：  
    1 块石头放入背包 0 ，1 块石头放入背包 1 。  
    每个背包中的石头总数是 [2,3,4,4] 。  
    背包 0 、背包 1 和 背包 2 都装满石头。  
    总计 3 个背包装满石头，所以返回 3 。  
    可以证明不存在超过 3 个背包装满石头的情况。  
    注意，可能存在其他放置石头的方案同样能够得到 3 这个结果。 

    @tab 示例 2：
    
    输入：capacity = [10,2,2], rocks = [2,2,0], additionalRocks = 100  
    输出：3  
    解释：  
    8 块石头放入背包 0 ，2 块石头放入背包 2 。  
    每个背包中的石头总数是 [10,2,2] 。  
    背包 0 、背包 1 和背包 2 都装满石头。  
    总计 3 个背包装满石头，所以返回 3 。  
    可以证明不存在超过 3 个背包装满石头的情况。  
    注意，不必用完所有的额外石头。
    :::

    ::: tip 
    思路：**从最小开始贪心。** 要求最多能装满多少背包，可以先求出背包的空余容量，然后从小到大排序，把额外石头依次装满背包，直到石头用完，这时装满的背包数量就是所求。
    :::

    ```py
    class Solution:
    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:
        free = [c - r for c, r in zip(capacity, rocks)] # O(n)
        free.sort() # O(nlogn)
        for i, f in enumerate(free): # O(n)
            additionalRocks -= f
            if additionalRocks == 0:
                return i + 1
            elif additionalRocks < 0:
                return i
        return len(capacity)
    ```
    
    时间复杂度：$O(nlogn)$，其中 n 为 capacity 的长度。

    空间复杂度：$O(n)$。忽略排序的栈开销。


3. [1833. 雪糕的最大数量](https://leetcode.cn/problems/maximum-ice-cream-bars/description/)

    <Badge type="info" text="夏日炎炎，小男孩 Tony 想买一些雪糕消消暑。商店中新到 n 支雪糕，用长度为 n 的数组 costs 表示雪糕的定价，其中 costs[i] 表示第 i 支雪糕的现金价格。Tony 一共有 coins 现金可以用于消费，他想要买尽可能多的雪糕。注意：Tony 可以按任意顺序购买雪糕。给你价格数组 costs 和现金量 coins ，请你计算并返回 Tony 用 coins 现金能够买到的雪糕的 最大数量 。你必须使用计数排序解决此问题。" />

    ::: tabs
    @tab 示例 1：
    
    输入：costs = [1,3,2,4,1], coins = 7  
    输出：4  
    解释：Tony 可以买下标为 0、1、2、4 的雪糕，总价为 1 + 3 + 2 + 1 = 7 

    @tab 示例 2：
    
    输入：costs = [10,6,8,7,7,8], coins = 5  
    输出：0  
    解释：Tony 没有足够的钱买任何一支雪糕。

    @tab 示例 3：
    
    输入：costs = [1,6,3,1,2,5], coins = 20  
    输出：6  
    解释：Tony 可以买下所有的雪糕，总价为 1 + 6 + 3 + 1 + 2 + 5 = 18 。
    :::

    ::: tip 
    思路：**从最小开始贪心。** 要求买更多数量的雪糕，因此我们要尽可能买便宜的（小布丁而不是巧乐兹），把雪糕价格从小到大排序，然后购买即可。
    :::

    ```py
    class Solution:
    def maxIceCream(self, costs: List[int], coins: int) -> int:
        costs.sort() # O(nlogn)
        for i, c in enumerate(costs): # O(n)
            coins -= c
            if coins == 0:
                return i + 1
            elif coins < 0:
                return i
        return len(costs)
    ```
    
    时间复杂度：$O(nlogn)$，其中 n 为 costs 的长度。

    空间复杂度：$O(1)$。忽略排序的栈开销。





