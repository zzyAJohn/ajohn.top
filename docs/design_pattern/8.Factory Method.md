---
title: '8. 工厂方法模式'
createTime: 2026/03/02 12:16:51
permalink: /design_pattern/w1zzejht/
---



工厂方法模式(Factory Method)，定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。

## 简单工厂模式

先回顾一下简单工厂模式：

@startuml

class Client {
  
    +createOperate() : Operation
}

abstract class Operation {
  +NumberA : double
  +NumberB : double
  +GetResult() : double
}

class OperationAdd {
  
  +GetResult() : double
}

class OperationSub {
  
  +GetResult() : double
}

class OperationMul {
  
  +GetResult() : double
}

class OperationDiv {
  
  +GetResult() : double
}

Client -> Operation
Operation <|-- OperationAdd
Operation <|-- OperationSub
Operation <|-- OperationMul
Operation <|-- OperationDiv


@enduml


抽象运算类：



```c#
public abstract class Operation
{
    public double NumberA { get; set; }
    public double NumberB { get; set; }

    public abstract double GetResult();
}
```

具体运算类：

```c#
public class OperationAdd : Operation
{
    public override double GetResult()
    {
        return NumberA + NumberB;
    }
}

public class OperationSub : Operation
{
    public override double GetResult()
    {
        return NumberA - NumberB;
    }
}

public class OperationMul : Operation
{
    public override double GetResult()
    {
        return NumberA * NumberB;
    }
}

public class OperationDiv : Operation
{
    public override double GetResult()
    {
        if (NumberB == 0)
            throw new DivideByZeroException("除数不能为0");

        return NumberA / NumberB;
    }
}
```

简单工厂类：

```c#
public class OperationFactory
{
    public static Operation CreateOperate(string operate)
    {
        Operation oper = null;

        switch (operate)
        {
            case "+":
                oper = new OperationAdd();
                break;

            case "-":
                oper = new OperationSub();
                break;

            case "*":
                oper = new OperationMul();
                break;

            case "/":
                oper = new OperationDiv();
                break;

            default:
                throw new ArgumentException("不支持的运算符");
        }

        return oper;
    }
}
```

客户端调用：

```c#
Operation oper = OperationFactory.CreateOperate("+");
oper.NumberA = 1;
oper.NumberB = 2;

double result = oper.GetResult();
Console.WriteLine(result);  // 输出 3
```
::: important
简单工厂模式的最大优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。
:::
“就像计算器，让客户端不用管该用哪个类的实例，只需要把‘+’给工厂，工厂自动就给出了相应的实例，客户端只要去做运算就可以了，不同的实例会实现不同的运算。但问题也就在这里，如你所说，如果要加一个‘求M数的N次方的功能’，我们是一定需要给运算工厂类的方法里加‘Case’的分支条件的，修改原有的类？这可不是好办法，这就等于说，我们不但对扩展开放了，对修改也开放了，这样就违背了什么原则？”“哦，是的，==违背的是开放-封闭原则==。”“对，于是工厂方法就来了。”

## 工厂方法模式


“我们讲过，既然这个工厂类与分支耦合，那么我就对它下手，根据==依赖倒转原则==，我们把工厂类抽象出一个接口，这个接口只有一个方法，就是创建抽象产品的工厂方法。然后，所有的要生产具体类的工厂，就去实现这个接口，这样，一个简单工厂模式的工厂类，变成了一个工厂抽象接口和多个具体生成对象的工厂，于是我们要增加‘求M数的N次方’的功能时，就不需要更改原有的工厂类了，只需要增加此功能的运算类和相应的工厂类就可以了。”

@startuml



'=====================
' 抽象产品
'=====================
abstract class Operation {
    +NumberA : double
    +NumberB : double
    +GetResult() : double
}

'=====================
' 具体产品
'=====================
class OperationAdd {
    +GetResult() : double
}

class OperationSub {
    +GetResult() : double
}

class OperationMul {
    +GetResult() : double
}

class OperationDiv {
    +GetResult() : double
}

Operation <|-- OperationAdd
Operation <|-- OperationSub
Operation <|-- OperationMul
Operation <|-- OperationDiv


'=====================
' 抽象工厂
'=====================
interface IFactory {
    +CreateOperation() : Operation
}

'=====================
' 具体工厂
'=====================
class AddFactory {
    +CreateOperation() : Operation
}

class SubFactory {
    +CreateOperation() : Operation
}

class MulFactory {
    +CreateOperation() : Operation
}

class DivFactory {
    +CreateOperation() : Operation
}

IFactory <|-- AddFactory
IFactory <|-- SubFactory
IFactory <|-- MulFactory
IFactory <|-- DivFactory

IFactory ..> Operation
AddFactory ..> OperationAdd
SubFactory ..> OperationSub
MulFactory ..> OperationMul
DivFactory ..> OperationDiv


@enduml
工厂接口：
```C#
public interface IFactory
{
    Operation CreateOperation();
}
```
抽象运算类：
```C#
public abstract class Operation
{
    public double NumberA { get; set; }
    public double NumberB { get; set; }

    public abstract double GetResult();
}
```
具体运算类：
```C#
public class OperationAdd : Operation
{
    public override double GetResult()
    {
        return NumberA + NumberB;
    }
}

public class OperationSub : Operation
{
    public override double GetResult()
    {
        return NumberA - NumberB;
    }
}

public class OperationMul : Operation
{
    public override double GetResult()
    {
        return NumberA * NumberB;
    }
}

public class OperationDiv : Operation
{
    public override double GetResult()
    {
        if (NumberB == 0)
            throw new DivideByZeroException("除数不能为0");

        return NumberA / NumberB;
    }
}
```
具体工厂类：
```C#
// 加法工厂
public class AddFactory : IFactory
{
    public Operation CreateOperation()
    {
        return new OperationAdd();
    }
}

// 减法工厂
public class SubFactory : IFactory
{
    public Operation CreateOperation()
    {
        return new OperationSub();
    }
}

// 乘法工厂
public class MulFactory : IFactory
{
    public Operation CreateOperation()
    {
        return new OperationMul();
    }
}

// 除法工厂
public class DivFactory : IFactory
{
    public Operation CreateOperation()
    {
        return new OperationDiv();
    }
}
```

客户端代码：

```C#
IFactory operFactory = new AddFactory();

Operation oper = operFactory.CreateOperation();
oper.NumberA = 1;
oper.NumberB = 2;

double result = oper.GetResult();

Console.WriteLine(result);   // 输出 3
```

“其实你仔细观察就会发现，工厂方法模式实现时，客户端需要决定实例化哪一个工厂来实现运算类，选择判断的问题还是存在的，也就是说，工厂方法把简单工厂的内部逻辑判断移到了客户端代码来进行。你想要加功能，本来是改工厂类的，而现在是修改客户端！”

::: tip
工厂方法模式是简单工厂模式的进一步抽象和推广。由于使用了多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。但缺点是由于每加一个产品，就需要加一个产品工厂的类，增加了额外的开发量。
:::