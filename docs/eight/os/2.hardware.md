---
title: '二、硬件结构'
createTime: 2025/11/03 17:18:08
permalink: /eight/m44kbedw/
---


## TODO

前面待补齐



## 2.7 为什么 0.1 + 0.2 不等于 0.3 ?

### Q：为什么负数要用补码表示?

如果负数不是使用补码的方式表示，则在做基本对加减法运算的时候，还需要多一步操作来判断是否为负数，如果为负数，还得把加法反转成减法，或者把减法反转成加法，这就非常不好了，毕竟加减法运算在计算机里是很常使用的，所以为了性能考虑，应该要尽量简化这个运算过程。


### Q：十进制小数怎么转成二进制?

十进制整数转二进制使用的是「除2取余法」，十进制小数使用的是「乘2 取整法」。

### Q：计算机是怎么存小数的?

计算机是以浮点数的形式存储小数的，大多数计算机都是 IEEE 754 标准定义的浮点数格式，包含三个部分:
- 符号位:表示数字是正数还是负数，为0表示正数，为1表示负数;
- 指数位:指定了小数点在数据中的位置，指数可以是负数，也可以是正数，指数位的长度越长则数值的表达范围就越大;
- 尾数位:小数点右侧的数字，也就是小数部分，比如二进制1.0011x2^(-2)，尾数部分就是 0011，而且尾数的长度决定了这个数的精度，因此如果要表示精度更高的小数，则就要提高尾数位的长度;
用 32 位来表示的浮点数，则称为单精度浮点数，也就是我们编程语言中的 float 变量，而用 64 位来表示的浮点数，称为双精度浮点数，也就是 double 变量。

### Q：0.1 + 0.2 == 0.3 吗?

不是的，0.1和 0.2 这两个数字用二进制表达会是一个一直循环的二进制数，比如0.1 的二进制表示为 0.0 0011 0011 0011..(0011 无限循环)，对于计算机而言，0.1无法精确表达，这是浮点数计算造成精度损失的根源。

因此，IEEE 754 标准定义的浮点数只能根据精度舍入，然后用「近似值」来表示该二进制，那么意味着计算机存放的小数可能不是一个真实值。

0.1 + 0.2 并不等于完整的 0.3，这主要是因为这两个小数无法用「完整」的二进制来表示，只能根据精度舍入，所以计算机里只能采用近似数的方式来保存，那两个近似数相加，得到的必然也是一个近似数。

